3.4.3 General Purpose Messages 
[JP] File Identifier 

struct FileId {85} {
a1 id[5]; // File type identifiera1 description[80]; // Human-readable stream description

}; 

This message, that is intended to be put at the beginning of the file, serves two purposes. 
First, it enables the processing program to easily identify the file type. Second, this message 
usually contains some additional information about the origin of the corresponding 
file (e.g., what particular hardware was used to collect data this file contains). 

Both the “id” and the “description” fields are padded to the required size with spaces if 
necessary. 

For JAVAD GNSS receivers, the [JP] message always contains the following information: 
“id” = “RLOGF”, and “description” = “JPS NAME Receiver log-file” (blanks are 
omitted here), where the sub-string “NAME” stands for the specific receiver name. 

Note: 
The size of this message is not subject to change. Therefore, the first 5 bytes of this message are 
always “JP055”, and specifically for this message generated by receiver, the first 10 bytes are 
always “JP055RLOGF”. 

68 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Time Messages 

[MF] Messages Format 

struct MsgFmt {9} {
a1 id[2]=”JP”; // JP identifier 
a1 majorVer[2]; // Format major version as decimal (e.g., '01') 
a1 minorVer[2]; // Format minor version as decimal 
a1 order; // Bytes order

// '0' — LSB first;
// '1' — MSB first 
a1 cs[2]; // Checksum formatted as hexadecimal 
}; 


Note: 
The size of this message is not subject to change. Therefore, the first 7 bytes of this message are 
always “MF009JP”. 

The data field order describes how multi-byte binary types are stored inside the message 
bodies. 

Note: 
For message format version 1.0, order is always set to “0”. Receiver always generates data in the 
least significant bytes first order. 

The message format's major version is updated if and only if some backward incompatible 
changes to the existing message format are made. Any other changes to the existing 
messages result in updating only the minor version. 

3.4.4 Time Messages 
[~~](RT) Receiver Time4 

This message contains the “time of day” part of the full receiver time representation 
(Tr). 

struct RcvTime {5} {
u4 tod; // Tr modulo 1 day (86400000 ms) [ms]
u1 cs; // Checksum 


}; 

This message is intended to be used as a “start of epoch” marker. 

[::](ET) Epoch Time5 

struct EpochTime {5} {
u4 tod; // Tr modulo 1 day (86400000 ms) [ms]
u1 cs; // Checksum 


}; 

4. Use message name /msg/jps/RT to enable/disable the message. 
5. Use message name /msg/jps/ET to enable/disable the message. 
GREIS 
www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Time Messages 

This message is intended to be used as an “end of epoch” marker. Provided the [~~](RT) 
message is used as “start of epoch” marker and [::](ET) is used as “end of epoch” 
marker, one can check that time tags from the messages from given epoch match to 
increase integrity checking capability of the stream decoding algorithm. 

[RD] Receiver Date 

struct RcvDate {6} {
u2 year; // Current year [1…65534][] 
u1 month; // Current month [1…12] []
u1 day; // Current day [1…31] [] 
u1 base; // Receiver reference time [enumerated]

// 0 — GPS 
// 1 — UTC_USNO 
// 2 — GLONASS 
// 3 — UTC_SU 
// 4…254 — Reserved 

u1 cs; // Checksum 
}; 


This message contains the “date” part of the full receiver time representation (Tr). 

[TO] Reference Time to Receiver Time Offset 

struct RcvTimeOffset {17} {
f8 val; // Trr - Tr [s]
f8 sval; // Smoothed (Trr - Tr) [s]
u1 cs; // Checksum 


}; 

[DO] Derivative of Receiver Time Offset 

struct RcvTimeOffsetDot {9} {
f4 val; // Derivative of (Trr - Tr) [s/s]
f4 sval; // Smoothed derivative of (Trr - Tr) [s/s]
u1 cs; // Checksum 

}; 

[BP] Rough Accuracy of Time Approximation 

struct RcvTimeAccuracy {5} {
f4 acc; // Accuracy [s]
u1 cs; // Checksum 


}; 

If the value of accuracy is greater than 10-3[s], it means that receiver clock may not be 
properly synchronized to receiver reference time (Trr). 

70 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Time Messages 

[GT] GPS Time 

struct GPSTime {7} {
u4 tow; // Time of week [ms]
u2 wn; // GPS week number (modulo 1024) [] 
u1 cs; // Checksum 

}; 

[GO] GPS to Receiver Time Offset 

struct RcvGPSTimeOffset {17} {
f8 val; // (Tg - Tr) [s]
f8 sval; // Smoothed (Tg - Tr) [s]
u1 cs; // Checksum 


}; 

[NT] GLONASS Time 

struct GLOTime {7} {
u4 tod; // time of day [ms]
u2 dn; // GLONASS day number (modulo 4 years

// starting from 1996) [] 
u1 cs; // Checksum 
}; 


[NO] GLONASS to Receiver Time Offset 

struct RcvGLOTimeOffset {17} {
f8 val; // (Tn - Tr) [s]
f8 sval; // Smoothed (Tn - Tr) [s]
u1 cs; // Checksum 


}; 

[EO] GALILEO to Receiver Time Offset 

struct RcvGALTimeOffset {17} {
f8 val; // (Te - Tr) [s]
f8 sval; // Smoothed (Te - Tr) [s]
u1 cs; // Checksum 


}; 

[WO] SBAS to Receiver Time Offset 

struct RcvSBASTimeOffset {17} {
f8 val; // (Tw - Tr) [s]
f8 sval; // Smoothed (Tw - Tr) [s]
u1 cs; // Checksum 


}; 

GREIS www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Time Messages 

[QO] QZSS to Receiver Time Offset 

struct RcvQZSSTimeOffset {17} {
f8 val; // (Tq - Tr) [s]
f8 sval; // Smoothed (Tq - Tr) [s]
u1 cs; // Checksum 


}; 

[CO] BeiDou to Receiver Time Offset 

struct RcvBeiDouTimeOffset {17} {
f8 val; // (Tb - Tr) [s]
f8 sval; // Smoothed (Tb - Tr) [s]
u1 cs; // Checksum 


}; 

[Io] IRNSS to Receiver Time Offset 

struct RcvIrnssTimeOffset {17} {
f8 val; // (Ti - Tr) [s]
f8 sval; // Smoothed (Ti - Tr) [s]
u1 cs; // Checksum 


}; 

[UO] GPS UTC Time Parameters 

struct GpsUtcParam {24} {
UtcOffs utc; // GPS UTC time offset parametersu1 cs; // Checksum 

}; 

struct UtcOffs {23} {
f8 a0; // Constant term of polynomial [s] 
f4 a1; // First order term of polynomial [s/s] 
u4 tot; // Reference time of week [s] 
u2 wnt; // Reference week number [] 
i1 dtls; // Delta time due to leap seconds [s] 
u1 dn; // 'Future' reference day number [1…7] [] 
u2 wnlsf; // 'Future' reference week number [] 
i1 dtlsf; // 'Future' delta time due to leap seconds [s]

}; 

This message describes the relationship between UTC(USNO) and GPS time as specified 
by GPS subframe 4, page 18. 

For how to convert GPS time into UTC(USNO), see ICD-GPS-200C, Revision IRN200C-
004 April 12, 2000. 

72 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Time Messages 

[WU] SBAS UTC Time Parameters 

struct SbasUtcParam {32} {

UtcOffs utc; // SBAS to UTC time offset parameters

i1 utcsi; // UTC Standard Identifier[] 

u4 tow; // Reference time of week [s] 

u2 wn; // Reference week number [] 

u1 flags; // Flags, reserved (always 0) 

u1 cs; // Checksum 

}; 

This message has much in common with the [UO] message. The utcsi field may have 
one of the following values: 

Table 3-5. UTC Standard Identifier 

Value Meaning 
0 UTC as operated by the Communications Research Laboratory (CRL), Tokyo, 
Japan 
1 UTC as operated by the National Institute of Standards and Technology (NIST) 
2 UTC as operated by the U. S. Naval Observatory (USNO) 
3 UTC as operated by the International Bureau of Weights and Measures (BIPM) 
[4…7] Reserved 

[EU] GALILEO UTC and GPS Time Parameters 

struct GalUtcGpsParam {40} {
UtcOffs utc; // GALILEO to UTC time offset parameters// GALILEO to GPS time offset parametersf4 a0g; // Constant term of time offset [s] 
f4 a1g; // Rate of time offset [s/s] 
u4 t0g; // Reference time of week 
u2 wn0g; // Reference week number 
u2 flags; // Flags of data availability [bitfield]

// 0 - GGTO availability 
// 1…15 - reserved 
u1 cs; // Checksum 
}; 


[QU] QZSS UTC Time Parameters 

struct QzssUtcParam {24} {
UtcOffs utc; // QZSS UTC time offset parameters
u1 cs; // Checksum 


}; 

[CU] BeiDou UTC Time Parameters 

struct BeiDouUtcParam {24} {
UtcOffs utc; // BeiDou UTC time offset parametersu1 cs; // Checksum 

}; 

GREIS www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Position/Velocity Messages 

[IU] IRNSS UTC Time Parameters 

struct IrnssUtcParam {24} {

UtcOffs utc; // IRNSS UTC time offset parameters

u1 cs; // Checksum 

}; 

[NU] GLONASS UTC and GPS Time Parameters 

struct GloUtcGpsParam {27} {

f8 tauSys; // Time correction to GLONASS time scale (vs. UTC(SU))

// tauSys = Tutc(su) - Tglo [s]

f4 tauGps; // tauGps = Tgps - Tglo [s]

f4 B1; // Coefficient for calculation of UT1 

f4 B2; // Coefficient for calculation of UT1 

u1 KP; // Leap second information 

u1 N4; // Number of 4-year cycle [1…31] 

i2 Dn; // Day number within 4-year period [] 

i2 Nt; // Current day number at the decoding time 

u1 cs; // Checksum 

}; 

This message contains GLONASS UTC and GPS time paramters. Please refer to 
GLONASS ICD for details. 

3.4.5 Position/Velocity Messages 
[ST] Solution Time-Tag 

struct SolutionTime {6} {

u4 time; // Solution time. Tr modulo 1 day (86400000 ms)[ms]

u1 solType; // Solution type

u1 cs; // Checksum 

}; 

Specifies the receiver time of the current position solution. Note that this time-tag may 
differ from the current receiver time if the receiver runs in RTK delay mode. In this case 
the time tag from this message is typically in the past with respect to the time tag of the 
current epoch. 

[PO] Cartesian Position 

struct Pos {30} {

f8 x, y, z; // Cartesian coordinates [m]

f4 pSigma; // Position SEP6 [m] 

u1 solType; // Solution type

u1 cs; // Checksum 

}; 

6. SEP stands for Spherical Error Probable 
74 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Position/Velocity Messages 

[Po] (PoWgs,PoLoc) Cartesian Position in Specific System 

struct SpecificCrtPos {36} {
f8 x, y, z; // Cartesian coordinates [m] 
f4 pSigma; // Position SEP [m] 
u1 solType; // Solution type 
u1 system; // Source of position


// 0 - WGS

// 1 - Local
a1 crsCode[5]; // Name of the coordinate reference system
u1 cs; // Checksum 


}; 

When enabled as /msg/jps/PoWgs, the resulting message will contain WGS coordinates 
and corresponding value 0 in its system field. 

When enabled as /msg/jps/PoLoc, the resulting message will contain coordinates in local 
coordinate system and corresponding value 1 in its system field. 

[VE] Cartesian Velocity 

struct Vel {18} {
f4 x, y, z; // Cartesian velocity vector [m/s]
f4 vSigma; // Velocity SEP [m/s]
u1 solType; // Solution type
u1 cs; // Checksum 


}; 

[PV] Cartesian Position and Velocity 

struct PosVel {46} {
! f8 x, y, z; // Cartesian coordinates [m] 
! f4 pSigma; // Position SEP [m]
! f4 vx, vy, vz; // Cartesian velocities [m/s] 
! f4 vSigma; // Velocity SEP [m/s] 


u1 solType; // Solution type 
u1 cs; // Checksum 
}; 


[PG] Geodetic Position 

struct GeoPos {30} {
f8 lat; // Latitude [rad] 
f8 lon; // Longitude [rad] 
f8 alt; // Ellipsoidal height [m] 
f4 pSigma; // Position SEP [m]
u1 solType; // Solution type
u1 cs; // Checksum 


}; 

GREIS www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Position/Velocity Messages 

[Pg] (PgWgs,PgLoc) Geodetic Position in Specific System 

struct SpecificCrtPos {36} {
f8 lat; // Latitude [rad] 
f8 lon; // Longitude [rad] 
f8 alt; // Ellipsoidal height [m] 
f4 pSigma; // Position SEP [m] 
u1 solType; // Solution type 
u1 system; // Coordinate system


// 0 - WGS

// 1 - Locala1 crsCode[5]; // Name of the coordinate reference systemu1 cs; // Checksum 

}; 

When enabled as /msg/jps/PgWgs, the resulting message will contain WGS coordinates 
and corresponding value 0 in its system field. 

When enabled as /msg/jps/PgLoc, the resulting message will contain coordinates in local 
coordinate system and corresponding value 1 in its system field. 

[VG] Geodetic Velocity 

struct GeoVel {18} {
f4 lat; // Northing velocity [m/s] 
f4 lon; // Easting velocity [m/s] 
f4 alt; // Height velocity [m/s] 
f4 vSigma; // Velocity SEP [m/s]
u1 solType; // Solution type
u1 cs; // Checksum 


}; 

[SG] Position and Velocity RMS Errors 

struct Rms {18} {
! f4 hpos; // Horizontal position RMS error[m] 
! f4 vpos; // Vertical position RMS error [m] 
! f4 hvel; // Horizontal velocity RMS error [m/s] 
! f4 vvel; // Vertical velocity RMS error [m/s]


u1 solType; // Solution type
u1 cs; // Checksum 
}; 


[mp] Position in Local Plane 

struct LocalPlanePos {42} {
f8 n; // Northern coordinate [m] 
f8 e; // Eastern coordinate [m] 
f8 u; // Altitude above local ellipsoid [m] 
f8 sep; // Geoid separation relatively to local ellipsoid [m] 
f4 pSigma; // Position SEP [m]
u1 solType; // Solution typeu1 grid; // Grid source

// 0 - none 

76 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Position/Velocity Messages 

// 1 - predefined grid 
// 2 - user defined grid 
// 3 - result of localization 
// 4 - grid got from external source 

u1 geoid; 
// Geoid source
// 0 - none 
// 1 - predefined geoid 
// 2 - user defined geoid 
// 4 - geoid got from external source 


u2 prj; // EPSG code of used projection 
u1 cs; // Checksum 
}; 


[bp] Reference Station Position in Local Plane 

struct RSLocalPlanePos {42} {
f8 n; // Northern coordinate [m] 
f8 e; // Eastern coordinate [m] 
f8 u; // Altitude above local ellipsoid [m] 
f8 sep; // Geoid separation relatively to local ellipsoid [m] 
f4 pSigma; // Position SEP [m]
u1 solType; // Solution typeu1 grid; // Grid source

// 0 - none 
// 1 - predefined grid 
// 2 - user defined grid 
// 3 - result of localization 
// 4 - grid got from external source 

u1 geoid; 
// Geoid source
// 0 - none 
// 1 - predefined geoid 
// 2 - user defined geoid 
// 4 - geoid got from external source 


u2 prj; // EPSG code of used projection 
u1 cs; // Checksum 
}; 


[DP] Dilution of Precision (DOP) 

struct Dops {18} {
f4 hdop; // Horizontal dilution of precision (HDOP)[] 
f4 vdop; // Vertical dilution of precision (VDOP) [] 
f4 tdop; // Time dilution of precision (TDOP) []
u1 solType; // Solution type
f4 edop; // East dilution of precision (eDOP) [] 
u1 cs; // Checksum 


}; 

[SP] Position Covariance Matrix 

struct PosCov {42} {
f4 xx; // [m^2] 
f4 yy; // [m^2] 
f4 zz; // [m^2] 
f4 tt; // [m^2] 
f4 xy; // [m^2] 


GREIS 
www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Position/Velocity Messages 

f4 xz; // [m^2] 

f4 xt; // [m^2] 

f4 yz; // [m^2] 

f4 yt; // [m^2] 

f4 zt; // [m^2]

u1 solType; // Solution type

u1 cs; // Checksum 

}; 

[SV] Velocity Covariance Matrix 

struct VelCov {42} {

f4 xx; // [(m/s)^2] 

f4 yy; // [(m/s)^2] 

f4 zz; // [(m/s)^2] 

f4 tt; // [(m/s)^2] 

f4 xy; // [(m/s)^2] 

f4 xz; // [(m/s)^2] 

f4 xt; // [(m/s)^2] 

f4 yz; // [(m/s)^2] 

f4 yt; // [(m/s)^2] 

f4 zt; // [(m/s)^2]

u1 solType; // Solution type

u1 cs; // Checksum 

}; 

[BL] Baseline 

struct Baseline {34} {

f8 x, y, z; // Calculated baseline vector coordinates [m]

f4 sigma; // Baseline Spherical Error Probable (SEP) [m]

u1 solType; // Solution type

i4 time; // receiver time of the baseline estimate [s] 

u1 cs; // Checksum 

}; 

[bL] Attitude Baselines 

struct Baselines {52} {

f4 bl0[3]; // baseline vector M-S0 [m] 

f4 bl1[3]; // baseline vector M-S1 [m] 

f4 bl2[3]; // baseline vector M-S2 [m] 

f4 rms[3]; // estimated accuracies for baseline vectors [m]

u1 solType[3]; // solution types for baseline vectors

u1 cs; // Checksum

}; 

[mR] Attitude Full Rotation Matrix 

struct FullRotationMatrix {37} {

f4 q00, q01, q02; // components of the rotation matrix Q []

f4 q10, q11, q12; // components of the rotation matrix Q []

f4 q20, q21, q22; // components of the rotation matrix Q []

u1 cs; // Checksum 

}; 

78 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Position/Velocity Messages 

[PS] Position Statistics 

struct PosStat {9} {

u1 solType; // Solution type 

u1 gpsLocked; // Number of GPS SVs locked

u1 gloLocked; // Number of GLONASS SVs locked 

u1 gpsAvail; // Number of GPS SVs available for positioning 

u1 gloAvail; // Number of GLONASS SVs available for positioning 

u1 gpsUsed; // Number of GPS SVs used in positioning 

u1 gloUsed; // Number of GLONASS SVs used in positioning 

u1 fixProg; // Ambiguity fixing progress indicator

// controllable by RTK engine [%] 

u1 cs; // Checksum 

}; 

The fixProg field may vary from 0% to 100%, though in practice if raw measurements 
are good enough, the fixProg field rarely takes values other than zero. Just occasionally 
you can see fixProg to be 100%. This means that the engine has just finished fixing all 
available ambiguities. The fixProg will be dropped to zero immediately after it has 
reached 100%. 

If the fixProg field keeps varying between 0% and 100% exclusive, this means that not 
all of the ambiguities have been fixed. Here are possible reasons for such behavior: 

• You have just launched the RTK engine and it is trying to get a first fixed solution. 
• There is one or more problem satellites whose measurements prevent the engine 
from fixing all available ambiguities “in batch”. 
• The receiver has just started tracking one or more “new” satellites. It will take 
the RTK engine some time to fix these new ambiguities. 
Also note that if the solution type is “RTK fixed”, the number of SVs with float ambiguities 
is: 

gpsAvail + gloAvail - (gpsUsed + gloUsed) 

[PT] Time of Continuous Position Computation 

struct PosCompTime {5} {

u4 pt; // Continuous position computation time [s]

u1 cs; // Checksum

}; 

Specifies the time interval over which continuous position computation has been possible. 
If the receiver is unable to compute any position at the current epoch, the Time of 
Continuous Position Computation counter is zeroed. 

GREIS www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Satellite Measurements 

3.4.6 Satellite Measurements 
Generic Messages Description 

In this section we will focus on messages containing “satellite specific information”. 
These kinds of messages include satellite measurements (code and carrier phase measurements, 
elevations, azimuths, etc.). 

Different applications may utilize different sets of measurements. It is almost impossible 
to select a fixed set of combinations of satellite measurements that would be enough universal 
yet compact. Instead receiver provides dedicated message for each particular 
measurement type. Every individual measurement message contains some specific 
(“homogeneous”) data for the satellites tracked. 

For any given epoch, data for particular satellite is put at the same position (index) in all 
the messages. Satellite Index, that from now on is called SvsIdx in this manual, will 
establish correspondence between given satellite and the place of its observables in the 
messages. Message [SX] “Extended Satellite Index” is used to represent the SvsIdx in 
the data stream and should be used to establish and update the SvsIdx as the data stream 
is being processed. The number of satellites in SvsIdx, nSats, should also be obtained 
from the [SX] message. 

For multi-antenna receivers, given satellite will typically appear multiple times in 
SvsIdx, indexing observables obtained from different antennas. The [AN] message 
could then be used to determine which antenna the observables are obtained from. 

Most of the measurements messages may contain special values of corresponding types 
to indicate lack of data for particular satellite(s). Refer to Table 3-2, “Special Values for 
Fields,” on page 59 for details. 

Extended Satellite Identifier (ESI) 

Note: 
ESI obsoletes old enumeration system based on USI which range has been exhausted. Refer to 
“Backward Compatibility Considerations” for further discussion 

To handle data corresponding to satellites of different systems in a universal manner, we 
assign each satellite its Extended Satellite Identifier (ESI): 

struct ESI {2} {
! u1 ssid; // Satellite system identifier (SSID)
! u1 svid; // Satellite identifier (SVID) inside system
}; 


In particular, ESI is used in the [SX] message to represent the SvsIdx. 

80 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Satellite Measurements 

The following table describes ESI: 

Table 3-6. Extended Satellite Identifier (ESI) 

SSID Value GNSS System SVID Meaning and Range 
0 Unused. Ignore satellites with this SSID 0 
1 GPS (NAVSTAR) GPS PRNs [1…37] 
2 GLONASS FCN [-7…24]1,1272 
3 SBAS PRN [120…142] 
4 GALILEO PRN [1…49] 
5 QZSS PRN [193…197] 
6 BeiDou PRN [1…30] 
7 IRNSS PRN [1…7] 
[8…254] Reserved 0 
255 Unused. Ignore satellites with this USI 0 

1. 
Represented in tow’s complement (ie., as ‘i1’ rather than ‘u1’ field type) 
2. 
Represents satellite with unknown FCN. Could be useful when converting third-party GLONASS measurement file into 
GREIS format. 
Universal Satellite Identifier (USI) 

Warning: 
USI is obsolete. ESI should be preferred. Refer to “Backward Compatibility Considerations” 
for further discussion 

Each satellite is assigned its Universal Satellite Identifier (USI) as well as ESI. In particular, 
USI is used in now obsolete [SI] message — the historical way of representing the 
SvsIdx. 

The following table describes USI allocation: 

Table 3-7. Universal Satellite Identifiers (USI) Allocation 

USI Range Assigned Satellites 
0 Unused. Ignore satellites with this USI 
[1…37] GPS PRNs [1…37] 
[38…69] GLONASS FCNs [-7…24] 
70 GLONASS satellite with unknown FCN1 
[71…119] GALILEO PRNs [1…49] 
[120…142] SBAS PRNs [120…142] 
[143…192] Reserved 
[193…197] QZSS PRNs [193…197] 
[198…210] Reserved 
[211…247] BeiDou (COMPASS) PRNs [1…37] 

GREIS 
www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Satellite Measurements 

Table 3-7. Universal Satellite Identifiers (USI) Allocation 

USI Range Assigned Satellites 
[248…254] Reserved 
255 Unused. Ignore satellites with this USI 

1. 
Could be useful when converting third-party GLONASS 
measurement file into GREIS format. 
Satellite Signals Allocation and Frequencies 

Even though every satellite system has its own set of signals and their names, we conventionally 
call all the signals CA/L1, P/L1, P/L2, CA/L2, L5, and L1C in GREIS. Standard 
signal names of all supported satellite systems and their carrier frequencies, along 
with corresponding GREIS names, are shown in the following table: 

Table 3-8. Satellite Signals Allocation 

GREIS CA/L1 P/L1 P/L2 CA/L2 L5 L1C 
GPS 
MHz 
C/A 
1575.42 
P1 
1575.42 
P2 
1227.60 
L2C(L+M) 
1227.60 
L5(I+Q) 
1176.45 
L1C(I+Q) 
1575.42 
QZSS 
MHz 
C/A 
1575.42 
SAIF 
1575.42 
LEX(P+D) 
1278.75 
L2C(L+M) 
1227.60 
L5(I+Q) 
1176.45 
L1C(I+Q) 
1575.42 
SBAS 
MHz 
L1 
1575.42 
L5 
1176.45 
GALILEO 
MHz 
E1(B+C) 
1575.42 
E5 altboc 
1191.795 
E5B(I+Q) 
1207.14 
E6(B+C) 
1278.75 
E5A(I+Q) 
1176.45 
GLONASS 
MHz 
CA/L1 
L1frq1 
P1 
L1frq 
P2 
L2frq2 
CA/L2 
L2frq 
L3(I+Q) 
1202.025 
BeiDou 
MHz 
B1-1 
1561.098 
B1-2 
1589.742 
B2(B5B) 
1207.14 
B3 
1268.52 
B5A 
1176.45 
B1C 
1575.42 
IRNSS 
MHz 
L5 
1176.45 

1. 
L1frq = 1602 + FCN * 0.5625 
2. 
L2frq = 1246 + FCN * 0.4375 
Alignment of Phase Measurements 

Receiver provides phase measurements "as-is", applying no corrections whatsoever (no 
1/4 cycle, no 1/2 cycle, no any other), therefore phase relations (e.g., between GPS P2 
and L2C signals) are exactly as described in corresponding system ICD. For complex 
signals (composed of pilot and data signals) receiver phase always refers to the pilot 
(dataless) signal. 

82 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Satellite Measurements 

Backward Compatibility Considerations 

There are a few considerations that should be taken into account when designing an 
application that needs to support decoding of satellite measurements generated by old 
versions of the receiver firmware: 

1. 
Obsoleting of USI /[SI] by ESI/[SX] for enumeration of satellites. 
2. 
Introducing of [RX], [CR], [rx], [cr], [DX], [0d] messages to be able to represent 
satellites with no CA/L1 signal being track in delta-messages. 
3. 
Changes of Ksys and Asys coefficients of “Integer Pseudo-ranges” messages for 
some of GNSS systems while their support matured. 
4. 
Changes of satellite signals allocation for BeiDou 
5. Changes of USI allocation for BeiDou and IRNSS. 
Let’s discuss them in turn. 
ESI/[SX] Replacing USI/[SI] 

Once USI lack of space for new satellites and systems became an issue, the ESI has been 
introduced to replace USI, and, along with this, the [SX] message containing ESIs was 
implemented. For smooth transition, the default set of messages was set to include both 
[SI] and [SX] messages. 

New satellites that has no USI mapping have USI set to 255 in the [SI] message. 255 was 
always reserved and thus satellites with this USI should be ignored by all the conforming 
software. This lets carefully written old software continue to operate correctly if 
receiver outputs [SI] (either along with [SX] or not), as [SX] will be ignored as unknown 
message. 

New software caring for compatibility with old data should decode both [SX] and [SI] 
and use them as sources for SvsIdx. Simplest implementation seems to just update 
SvsIdx from both messages, taking care to never replace known satellite in the SvsIdx 
with an unknown one (0 or 255 USI or ESI.SSID). 

Decoding of Delta-messages 

Delta-messages formats rely on common (for given satellite at given epoch) reference 
being subtracted from all the values to minimize data size. These references pr_ref, 
PR_REF, and DP_REF, are used for different kinds of delta-messages. 

Historically, these references used to be taken from corresponding CA/L1 messages, 
[rc], [RC], and [DC], as receiver firmware was not able to track other signals without 
CA/L1 signal. At some point, requirement for CA/L1 tracking was relaxed, and thus the 
need to make delta-messages independent of CA/L1 tracking arose. At this point sepa-

GREIS 
www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Satellite Measurements 

rate messages to hold reference pseudo-ranges and doppler were introduced. This messages 
are [rx], [RX], and [DX]. In addition, new delta-messages to contain CA/L1 deltapseudo-
range and delta-doppler were implemented to make the entire system symmetric 
and CA/L1-independent. Notice that in the old representation these latter messages were 
not needed, as CA/L1 delta-pseudo-range and delta-doppler were always exactly zero 
due to definition of corresponding references. 

To preserve backward compatibility, the references are still defined so that they hold 
CA/L1 signal data, provided it is available, but newer software should not rely on this 
feature. Instead, it should prefer data from [rx], [RX], and [DX] over data from [rc], 
[RC], and [DC] for the purpose of defining of references pr_ref, PR_REF, and DP_REF, 
respectively. 

Overall, an algorithm for decoding of phases and pseudo-ranges from delta-messages 
could look like this (for dopplers the logic is similar to pseudo-ranges): 

step 0: clear ‘ignore_rc’ and ‘ignore_RC’ flags. 
step 1: loop: look for [rx], [rc], [RX], and [RC] messages:


 NOTE: do not populate values in CA/L1 pseudo-range arrays from 
either [rc] or [RC] here - better do this in loop 2, as part of 
common phases/pseudo-ranges decoding.

 - if [rx]: populate values in pr_ref array from corresponding valid 
values from [rx], unconditionally. (This will override value got 
from [rc], if any.) Set ‘ignore_rc’ flag. 
- if [rc]: if ‘ignore_rc’ is set, entirely ignore [rc] in this loop. 
Otherwise populate values in pr_ref array from corresponding valid 
values from [rc]. 
- if [RX]: populate values in PR_REF array from corresponding valid 
values from [RX], unconditionally. (This will override value got 
from [RC], if any.) Set ‘ignore_RC’ flag. 
- if [RC]: if ‘ignore_RC’ is set, entirely ignore [RC] in this loop. 
Otherwise populate values in PR_REF array from corresponding valid 
values from [RC]. 
84 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Satellite Measurements 

step 3: loop: for all pseudo-range and phase messages excluding [rx]/[RX]: 

NOTE: [rc] and [RC] should be decoded/processed here the same way 
as other pseudo-range messages. 

- To decode relative carrier phases [CP], [1P], …, [lP], use PR_REF. 
- To decode relative carrier phases [cp], [1p], …, [lp], use pr_ref. 
- To decode all the relative pseudo-range messages, use PR_REF if 
available, otherwise use pr_ref if available. 
Asys and Ksys Changes 

Unfortunately, over time a few changes to Asys and Ksys coefficients (see Table 3-9 on 
page 88) have been made for some GNSS systems. Here is the history of these changes: 

Firmware Version Issue Date What From To 
3.2.7b0 2011-04-12 GALILEO Asys 0.075 0.090 
3.5.6 2014-03-06 GALILEO Asys 
SBAS Asys 
0.090 
0.115 
0.085 
0.125 
3.7.0 2017-03-03 GALILEO Ksys 
1 1*10-11 2*10-11 

1. 
If there is either of [RX] or [CR] in the stream, then it's safe to assume new Ksys values as 
well. 
USI Allocation for BeiDou and IRNSS 

Starting from firmware version 3.7.0, IRNSS has been removed from USI, and BeiDou 
range has been extended into the cleared space. Firmware version could usually be taken 
from standard GREIS file from [PM] message being output at the beginning of each file. 

Satellite Signals Allocation for BeiDou 

Starting from firmware version 3.7.0, BeiDou B2 signal has been moved from L5 to P2 
slot. Firmware version could usually be taken from standard GREIS file from [PM] message 
being output at the beginning of each file. 

[SX] Extended Satellite Indices 

Note: 
This message obsoletes [SI] message. Refer to “Backward Compatibility Considerations” for further 
discussion 

GREIS 
www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Satellite Measurements 

struct ExtSatIndex {2*nSats+1} {
ESI esi[nSats]; // ESI array []
u1 cs; // Checksum 


}; 

The [SX] message contains ESI for each satellite in SvsIdx, thus establishing mutual 
correspondence between satellite identifier and array index allocated to this satellite. 
Decoding of [SX] is required to build and update the SvsIdx from the GREIS message 
stream. 

The number of satellites in the SvsIdx, nSats, should be calculated from the length of 
[SX] message body (taken from the message header): 

nSats = (length - 1) / 2 

From practical point of view, [SX] is the way to build and update the SvsIdx from the 
GREIS message stream. 

[SI] Satellite Indices 

Warning: 
This message is obsolete. [SX] should be preferred. Refer to “Backward Compatibility 
Considerations” for further discussion 

struct SatIndex {nSats+1} {
u1 usi[nSats]; // USI array []
u1 cs; // Checksum 


}; 

The [SI] message contains an array of USIs for every satellite in SvsIdx. [SI] was the 
way to build and update the SvsIdx from the GREIS message stream before [SX] has 
been introduced. Even newer software may need to decode the [SI] to be able to process 
files generated by old versions of receiver firmware. 

[AN] Antenna Names 

struct AntName{nSats+1} {
a1 name[nSats]; // Antenna names[a…z]
u1 cs; // Checksum 


}; 

This message contains antenna name (ASCII character in the range [a…z]) for every satellite 
in SvsIdx. 

This message is only available for multi-antenna receivers. 

86 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Satellite Measurements 

[NN] GLONASS Satellite System Numbers 

struct SatNumbers {nGloSats+1} {
! u1 osn[nGloSats]; // GLONASS SV orbit slot number []
u1 cs; // Checksum 
}; 


The [NN] message contains the orbit slot number for every GLONASS satellite in 
SvsIdx. Here nGloSats designates the number of GLONASS satellites in SvsIdx. 

[EL] Satellite Elevations 

struct SatElevation {nSats+1} {
! i1 elev[nSats]; // Elevation angle [degrees] [-90…90)
u1 cs; // Checksum 
}; 


This message contains elevations for all the satellites in SvsIdx. 

[AZ] Satellite Azimuths 

struct SatAzimuth {nSats+1} {
! u1 azim[nSats]; // Azimuth angle [degrees*2] [0…180)
u1 cs; // Checksum 
}; 


This message contains azimuths for all the satellites in SvsIdx. The notation [degrees*2] 
means that the values from the message must be multiplied by 2 to restore actual azimuths 
in degrees. 

[RX], [RC], [R1], [R2], [R3], [R5], [Rl]: Pseudo-ranges 

struct PR {8*nSats+1} {
! f8 pr[nSats]; // Pseudo-range, [s] 
u1 cs; // Checksum 
}; 


These messages contain corresponding pseudo-ranges for all the satellites in SvsIdx. 
The [RX] message contains virtual references PR_REF. The rest of the messages contain 
CA/L1, P/L1, P/L2, CA/L2, L5, and L1C pseudo-ranges, respectively. 

The PR_REF from the [RX] message is used for definition of relative pseudo-range and 
relative carrier phase messages. For backward compatibility, virtual reference pseudo-
range PR_REF is defined so that its value is equal to CA/L1 pseudo-range obtained from 
[RC] message whenever CA/L1 pseudo-range is available. This way old software that 
uses values from [RC] message to decode dependent messages will still obtain correct 
results. 

GREIS www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Satellite Measurements 

[rx], [rc], [r1], [r2], [r3], [r5], [rl]: Integer Pseudo-ranges 

struct SPR {4*nSats+1} {
! i4 spr[nSats]; // (PR[s] - Asys) / Ksys 
u1 cs; // Checksum 
}; 


These messages contain corresponding short pseudo-ranges for all the satellites in 
SvsIdx. The [rx] message contains short virtual references pr_ref. The rest of the messages 
contain CA/L1, P/L1, P/L2, CA/L2, L5, and L1C pseudo-ranges, respectively. 

Use the following formula to restore true pseudo-ranges in seconds: 
pr = spr *Ksys + Asys 
where: 

Table 3-9. System-specific Coefficients Ksys and Asys 

GNSS Ksys Asys 
GPS 1*10-11 0.075 
GLONASS 1*10-11 0.075 
GALILEO 2*10-11 0.085 
SBAS 1*10-11 0.125 
QZSS 2*10-11 0.125 
BeiDou 2*10-11 0.105 
IRNSS 2*10-11 0.105 

The pr_ref from the [rx] message is used for definition of relative pseudo-range and 
integer relative carrier phase messages. For backward compatibility, short virtual reference 
pseudo-range pr_ref is defined so that its value is equal to CA/L1 pseudo-range 
obtained from [rc] message whenever CA/L1 pseudo-range is available. This way old 
software that uses values from [rc] message to decode dependent messages will still 
obtain correct results. 

Note that pr_ref could also be calculated from PR_REF, but not vice versa. This could 
help to decode exotic combinations of messages where [rx] is not available, but there 
are some other messages that need pr_ref for their decoding, and [RX] happens to be 
there. To calculate pr_ref from PR_REF, use: 

pr_ref = trunc((PR_REF - Asys) / Ksys) * Ksys + Asys 

where trunc(x) function rounds x toward zero. 

[prr]: CA/L1 Relative Pseudo-range Combo 

88 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Satellite Measurements 

This virtual message enables output of [rc], [rx], and [cr] messages, implementing some 
interdependency rules to save space in the default set of messages and to promote 
smooth transition from [rc] to [rx] - based decoding. 

The interdependency rules are: 

1. 
[rc] is output as usual, if there is it least one CA/L1 pseudo-range measurement 
for it. 
2. 
[rx] is output only if there is at least one pseudo-range or phase measurement 
other than CA/L1 for an SVs with no CA/L1 measurements. 
3. 
[cr] is output only if both [rc] and [rx] are output. 
[CR], [1R], [2R], [3R], [5R], [lR]: Relative Pseudo-ranges 

struct RPR {4*nSats+1} {
! f4 rpr[nSats]; // PR - REF, [s]
u1 cs; // Checksum 
}; 


These messages contain relative CA/L1, P/L1, P/L2, CA/L2, L5, and L1C pseudo-
ranges, respectively, for all the satellites in SvsIdx. 
Use the following formula to restore true pseudo-range in seconds: 


pr = rpr + REF 
where REF is either of corresponding virtual reference pseudo-ranges pr_ref, or PR_REF, 
whatever is available. 

[cr], [1r], [2r], [3r], [5r], [lr]: Integer Relative Pseudo-ranges 

struct SRPR {2*nSats+1} {
! i2 srpr[nSats]; // (PR[s] - REF[s] - 2*10-7) * 1011 
u1 cs; // Checksum 
}; 


These messages contain short relative CA/L1, P/L1, P/L2, CA/L2, L5, and L1C pseudo-
ranges, respectively, for all the satellites in SvsIdx. 
Use the following formula to restore true pseudo-range in seconds: 


pr = srpr * 10-11 + 2*10-7 + REF 
where REF is either of corresponding virtual reference pseudo-ranges pr_ref, or PR_REF, 
whatever is available. 

GREIS 
www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Satellite Measurements 

[cm], [1m], [2m], [3m], [5m], [lm]: Pseudo-range Corrections 

struct PrCorr {2*nSats+2} {

! i2 prc[nSats]; // Correction [Seconds * 1e11]
u1 mode; // Mode
u1 cs; // Checksum 


}; 

Where mode corresponds to the value of /par/raw/corr/ca/code parameter as follows: 
0 – normal 
1 – data 

2 – mpear 
3 – mpnew 
4 – mp2ne 
5 – mpxne 


These messages contain CA/L1, P/L1, P/L2, CA/L2, L5, and L1C pseudo-range corrections, 
respectively, for all the satellites in SvIdx. They allow to compute alternative 
pseudo-ranges to those being output in pseudo-range messages (i.e., to compute corrected 
pseudo-ranges when mode is 0, and raw pseudo-ranges otherwise.) 

When mode is 1 (data), corrections are “data” pseudo-range minus “pilot” pseudo-range. 
For for all the other values of mode corrections are multipath corrections. 
Use the following formula to compute corrections in seconds: 
prcs = prc* 10-11 
Use the following formula to compute alternative pseudo-ranges: 

aprs = prs + prcs 
where prs is pseudo-range taken from corresponding pseudo-range message (e.g., from 
[RC]). 

[CC],[C1],[C2],[C3],[C5],[Cl]: Smoothing Corrections 

struct SC {6*nSats+1} {
! Smooth smooth[nSats]; // PR smoothing
u1 cs; // Checksum 
}; 


where “Smooth” format is defined as follows: 

struct Smooth {6} {
! f4 value; // Smoothing correction [s]
! u2 interval; // Smoothing interval [s]
}; 


90 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Satellite Measurements 

These messages contain corresponding pseudo-range smoothing corrections and corresponding 
smoothing intervals for all the satellites in SvsIdx. The messages contain 
CA/L1, P/L1, P/L2, CA/L2, L5, and L1C smoothing corrections, respectively. 

Use the following formula to compute smoothed pseudo-ranges in seconds: 

pr_sm = pr + smooth.value 

[cc],[c1],[c2],[c3],[c5],[cl]: Smoothing Corrections 

struct SS {2*nSats+1} {

! i2 smooth[nSats]; // Smoothing correction [s*10-11]
u1 cs; // Checksum 


}; 

These messages contain corresponding short pseudo-range smoothing corrections for all 
the satellites in SvsIdx. The [cc], [c1], [c2], [c3], [c5], and [cl] messages contain short 
CA/L1, P/L1, P/L2, CA/L2, L5, and L1C smoothing corrections, respectively. 

Use the following formula to compute smoothed pseudo-ranges in seconds: 

pr_sm = pr + smooth *10-11 

[PC], [P1], [P2], [P3], [P5], [Pl]: Carrier Phases 

struct CP {8*nSats+1} {

! f8 cp[nSats]; // CP, [cycles]
u1 cs; // Checksum 


}; 

These messages contain corresponding carrier phases for all the satellites in SvsIdx. The 

messages contain CA/L1, P/L1, P/L2, CA/L2, L5, and L1C carrier phases, respectively. 

[pc], [p1], [p2], [p3], [p5], [pl]: Integer Carrier Phases 

struct SCP {4*nSats+1} {

! u4 scp[nSats]; // CP, [cycles/1024]
u1 cs; // Checksum 


}; 

Note: 
The “scp” field will have discontinuities due to rollovers. Refer to “Compensating for Phase 
Rollovers” on page 499 for details. 

These messages contain corresponding short carrier phases for all the satellites in 
SvsIdx. The messages contain short CA/L1, P/L1, P/L2, CA/L2, L5, and L1C carrier 
phases, respectively. 

Use the following formula to compute full carrier phases in cycles: 

cp = scp / 1024.0 

GREIS 
www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Satellite Measurements 

[CP],[1P],[2P],[3P],[5P],[lP]: Relative Carrier Phases 

struct RCP_RC {4*nSats+1} {

! f4 rcp[nSats]; // cp / FLn - PR_REF [s] 
u1 cs; // Checksum 


}; 

These messages contain differences between the full corresponding carrier phases and 
the matching [RC] pseudo-ranges for all the satellites in SvsIdx. The messages contain 
CA/L1, P/L1, P/L2, CA/L2, L5, and L1C carrier phases, respectively. 

Use the following formula to compute true carrier phases in cycles: 

cp = (rcp + PR_REF) * FLn 

where: 

PR_REF – s the value taken from corresponding [RX] message, and converted to seconds 
as specified in the description of the [RX] message 

FLn – is nominal Ln carrier frequency for corresponding satellite, e.g., nominal L2 
frequency for [2P] and [3P] messages, and nominal L1 frequency for [CP] and [1P] 
messages. 

[cp],[1p],[2p],[3p],[5p],[lp]: Integer Relative Carrier Phases 

struct RCP_rc {4*nSats+1} {

! i4 rcp[nSats]; // cp / FLn - pr_ref, [s*2-40]
u1 cs; // Checksum 


}; 

These messages contain the differences between the full corresponding carrier phases 
and the matching [rx] pseudo-ranges for all the satellites in SvsIdx. The messages contain 
CA/L1, P/L1, P/L2, CA/L2, L5, and L1C carrier phases, respectively. 

Use the following formula to retrieve true carrier phases in cycles: 

cp = (rcp * 2-40 + pr_ref) * FLn 

where: 

pr_ref – is the value taken from corresponding [rx] message, and converted to seconds 
as specified in the description of the [rx] message. 

FLn – is nominal Ln carrier frequency for corresponding satellite, e.g., nominal L2 
frequency for [2p] and [3p] messages, and nominal L1 frequency for [cp] and [1p] 
messages. 

92 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Satellite Measurements 

[cf], [1f], [2f], [3f], [5f], [lf]: Phase Corrections 

struct PhCorr {2*nSats+2} {

! i2 phc[nSats]; // Correction [cycles * 1024]
u1 mode; // Mode
u1 cs; // Checksum 


}; 

Where mode corresponds to the value of /par/raw/corr/ca/carrier parameter as follows: 
0 – normal 
3 – mpnew 

These messages contain CA/L1, P/L1, P/L2, CA/L2, L5, and L1C phase corrections, 
respectively, for all the satellites in SvIdx. They allow to compute alternative phases to 
those being output in phase messages (i.e., to compute corrected phases when mode is 0, 
and raw phases otherwise.) 

When /par/raw/corr/ca/code is set to data and mode is 0, corrections are “data” phase 
minus “pilot” phase, otherwise the corrections are multipath corrections. 
Use the following formula to compute corrections in cycles: 
phcc = phc / 1024 
Use the following formula to compute alternative phases: 
aphcc = phc + phcc 
where phc is phase taken from corresponding phase message (e.g., from [PC]). 

[DX], [DC], [D1], [D2], [D3], [D5], [Dl]: Doppler 

struct DP {4*nSats+1} {
! i4 dp[nSats]; // DP [Hz*10-4]
u1 cs; // Checksum 
}; 


These messages contain corresponding doppler estimates for all the satellites in SvsIdx. 
The messages contain virtual reference DP_REF, CA/L1, P/L1, P/L2, CA/L2, L5, and 
L1C doppler, respectively. 

Use the following formula to compute true doppler: 

doppler = dp * 10-4 

The DP_REF from the [DX] message is used for definition of relative doppler messages. 
For backward compatibility, virtual reference doppler DP_REF is defined so that its value 
is equal to CA/L1 doppler obtained from [DC] message whenever CA/L1 doppler is 
available. This way old software that uses values from [DC] message to decode dependent 
messages will still obtain correct results. 

GREIS www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Satellite Measurements 

[drr]: CA/L1 Relative Doppler Combo 

This virtual message enables output of [DC], [DX], and [0d] messages, implementing 
some interdependency rules to save space in the default set of messages and to promote 
smooth transition from [DC] to [DX] - based decoding. 

The interdependency rules are: 

1. 
[DC] is output as usual, if there is it least one CA/L1 doppler measurement for 
it. 
2. 
[DX] is output only if there is at least one doppler measurement other than 
CA/L1 for an SVs with no CA/L1 doppler. 
3. 
[0d] is output only if both [DC] and [DX] are output. 
[0d],[1d], [2d], [3d], [5d], [ld]: Relative Doppler 

struct SRDP {2*nSats+1} {
! i2 srdp[nSats]; // (dp * FL1/FLn - dpCA1)[Hz*10-4]
u1 cs; // Checksum 
}; 


These messages contain corresponding short doppler relative to virtual reference doppler 
for all the satellites in SvsIdx. The messages contain CA/L1, P/L1, P/L2, CA/L2, 
L5, and L1C short relative doppler, respectively. 

Use the following formula to compute true doppler: 

doppler = (srdp + DP_REF) * FLn / FL1 * 10-4 

where: 

DP_REF – is the value dp taken from the [DX] message for given SV 
FL1 – is the nominal L1 frequency of the corresponding satellite. For IRNSS, use 
GPS L1 frequency. 
FLn – is the nominal Ln frequency of the corresponding satellite. 

[EC], [E1], [E2], [E3], [E5], [El]: SNR 

struct CNR {nSats+1} {
! u1 cnr[nSats]; // C/N0 [dB*Hz]
u1 cs; // Checksum 
}; 


These messages contain corresponding carrier to noise ratios for all the satellites in 
SvsIdx. The messages contain CA/L1, P/L1, P/L2, CA/L2, L5, and L1C carrier to noise 
ratio, respectively. 

94 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Satellite Measurements 

[CE], [1E], [2E], [3E], [5E], [lE]: SNR x 4 

struct CNR_4 {nSats+1} {
! u1 cnrX4[nSats]; // C/N0 [0.25*dB*Hz]
u1 cs; // Checksum 
}; 


These messages contain corresponding carrier to noise ratios for all the satellites in 
SvsIdx. The messages contain CA/L1, P/L1, P/L2, CA/L2, L5, and L1C carrier to noise 
ratio multiplied by 4, respectively. 

Use the following formula to compute true carrier to noise ratio in dB*Hz: 

cnr = cnrX4 * 0.25 

[s0], [s1], [s2], [s3], [s5], [sl]: SNR x 256 

struct CNR_256 {2*nSats+1} {
! u2 cnrX256[nSats]; // C/N0 [(1/256)*dB*Hz]
u1 cs; // Checksum 
}; 


These messages contain corresponding carrier to noise ratios for all the satellites in 
SvsIdx. The messages contain CA/L1, P/L1, P/L2, CA/L2, L5, and L1C carrier to noise 
ratio multiplied by 256, respectively. 

Use the following formula to compute true carrier to noise ratio in dB*Hz: 

cnr = cnrX256 / 256 

[j0], [j1], [j2], [j3], [j5], [jl]: Data SNR x 256 

struct CNR_256 {2*nSats+1} {
! u2 cnrX256[nSats]; // C/N0 [(1/256)*dB*Hz]
u1 cs; // Checksum 
}; 


These messages contain corresponding "data" (as opposed to “pilot”) sub-signal carrier 
to noise ratios for all the satellites in SvsIdx. The messages contain CA/L1, P/L1, P/L2, 
CA/L2, L5, and L1C carrier to noise ratio multiplied by 256, respectively. 

Use the following formula to compute true carrier to noise ratio in dB*Hz: 

cnr = cnrX256 / 256 

[FC],[F1],[F2],[F3],[F5],[Fl]: Signal Lock Loop Flags 

struct Flags {2*nSats+1} {
u2 flags[nSats]; // Lock Loop Flags [bitfield]
u1 cs; // Checksum 


}; 

GREIS www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Satellite Measurements 

These messages contain an array of corresponding signal lock loop flags for all the satellites 
in SvsIdx. The messages contain CA/L1, P/L1, P/L2, CA/L2, L5, and L1C signal 
lock loop flags, respectively. 

The following flags are defined: 

bit# Hex Mask Description 
0 0x0001 PLL is in phase lock 
1 0x0002 Satellite signal strength is sufficient 
2…3 0x0004 Unused 
4 0x0010 CLL is in steady state phase lock 
5 0x0020 Loss-of-lock occurred in PLL between the previous and the current epochs 
6 0x0040 Integral data quality indicator 
7 0x0080 Not Used 
8 0x0100 Preamble detected 
9 0x0200 “Data” signal is used in PLL/DLL (for “data+pilot” signals only) 
10 0x0400 “Pilot” signal is used in PLL/DLL (for “data+pilot” signals only) 
11 0x0800 Pseudo-range is not full pseudo-range and thus should not be used in position 
computation. This flag may appear when parameter 
/par/raw/meas/mode is set to modulo 
12…15 0xFE00 Reserved for internal purposes 

Note: 
bit#5 is not suitable for loss-of-lock detection in applications, – use [TC] message for this purpose 
instead. 

Note: 
bits #9 and #10: receiver tries to use both sub-signals, but in case of low C/N0 it automatically 
switches to pilot-only tracking. 

The simplest approach to data validation is keeping track of only bit #6. As long as this 
bit remains set for a particular satellite, all of this satellite's measurements for corresponding 
signal type are considered good. Note that the receiver normally utilizes very 
narrow CLL bandwidths, thus, quite a long settling-down time (tens of seconds). In fact, 
it is not worth waiting until the pseudo-range noise error reaches its steady-state level. 

Note that bit#6 is set as soon as the measured pseudo-ranges become “accurate enough” 
(i.e., irrespective of whether the formal settling-down period is over or not). On the other 
hand, for code differential applications, pseudo-range accuracy is of critical importance. 
If bit#4 is set, this indicates that the corresponding pseudo-ranges are generated after the 
loop having reached the “steady state” and therefore are considered the least noisy. 

In fact, it is not infrequent that raw data are used even if bit #6 is not set. In such cases, 
however, all responsibility for providing valid results rests with the user. 

Bits ##0…3 are used for internal purposes. 

96 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Satellite Measurements 

[ec], [e1], [e2], [e3], [e5]: Raw Inphases (I) 

struct IAmp {2*nSats+1} {
! i2 amp[nSats]; // (I) amplitudes
u1 cs; // Checksum 
}; 


These messages contain signal inphase (I) amplitudes for all the satellites in SvsIdx. The 
messages contain CA/L1, P/L1, P/L2, CA/L2, and L5 amplitudes, respectively. The 
amplitudes are smoothed over the interval specified by the /par/raw/iqsmi parameter. 

[qc], [q1], [q2], [q3], [q5]: Raw Quadratures (Q) 

struct QAmp {2*nSats+1} {
! i2 amp[nSats]; // (Q) amplitudes
u1 cs; // Checksum 
}; 


These messages contain signal quadrature (Q) amplitudes for all the satellites in SvsIdx. 
The messages contain CA/L1, P/L1, P/L2, CA/L2, and L5 amplitudes, respectively. The 
amplitudes are smoothed over the interval specified by the /par/raw/iqsmi parameter. 

[TC] CA/L1 Continuous Tracking Time 

struct TrackingTimeCA {2*nSats+1} {
u2 tt[nSats]; // tracking time [s] 
u1 cs; // Checksum 


}; 

This message contains time elapsed since the last loss-of-lock on the CA/L1 signal for 
every satellite in SvsIdx. 

[TC] time is measured in seconds. Each satellite is allocated its own TC-time counter. 
Count-up begins with zero and stops when the counter reaches the maximum value the 
“u2” data type allows. Please note that the TC-time counters are not subject to rollovers. 

Given a satellite, TC-time count starts as soon as the C/A signal is locked on. Should a 
loss of lock occur when tracking the C/A signal, the TC-time counter is reset to zero. 

[SS] Satellite Navigation Status 

struct NavStatus {nSats+2} {
u1 ns[nSats]; // Navigation Status
u1 solType; // Solution type 
u1 cs; // Checksum 


}; 

This message contains navigation status for all the satellites in SvsIdx. In addition, this 
message indicates which receiver positioning mode the status belongs to. For detailed 
information on the navigation status, see “Satellite Navigation Status” on page 66. 

GREIS www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Almanacs and Ephemeris 

[ID] Ionospheric Delays 

struct IonoDelay {4*nSats+1} {
! f4 delay[nSats]; // Ionospheric delay [s] 
u1 cs; // Checksum 
}; 


This message contains estimated ionospheric delays as computed by using the L1 minus 
L2 frequency combination for all the satellites in SvsIdx. 

[rr] Satellite Range Residuals 

struct RangeResidual {4*nSats+1} {
! f4 res[nSats]; // Range residual [m] 
u1 cs; // Checksum 
}; 


[vr] Satellite Velocity Residuals 

struct VelocityResidual {4*nSats+1} {
! f4 res[nSats]; // Radial velocity residual [m] 
u1 cs; // Checksum 
}; 

3.4.7 Almanacs and Ephemeris 
[GA] GPS Almanac 

struct GPSAlm {47} {
u1 sv; // SV PRN number within the range [1…37] 
i2 wna; // Almanac reference week [] 
i4 toa; // Almanac reference time of week [s]
u1 healthA; // Health summary (from almanac), [bitfield]

// 0…4 - code for health of SV signal components 

// 5…7 - navigation data health indicatorsu1 healthS; // Satellite health (page 25 of subframe 5) []
u1 config; // Satellite configuration (page 25 of subframe 4)

// [bitfield]: 
// 0…2 - satellite configuration 
// 3 - anti-spoofing flag 
// 4…7 - reserved 

//======= Clock data =======
f4 af1; // Polynomial coefficient [s/s] 
f4 af0; // Polynomial coefficient [s]
//===== Ephemeris data =====
//--- Keplerian orbital parameters --
f4 rootA; // Square root of the semi-major axis [m^0.5] 
f4 ecc; // Eccentricity [] 
f4 m0; // Mean Anomaly at reference time [semi-circles] 
f4 omega0; // Longitude of ascending node of orbit plane


// at the start of week ‘wna’ [semi-circles] 
f4 argPer; // Argument of perigee [semi-circles]
//--- Corrections to orbital parameters --


98 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Almanacs and Ephemeris 

f4 deli; // Correction to inclination angle [semi-circles]

f4 omegaDot; // Rate of right ascension [semi-circle/s]

u1 cs; // Checksum 

}; 

[EA] GALILEO Almanac 

struct GALAlm {49} {

// GPS-alike data

GPSAlm gps; // Without ‘cs’ field, gps.sv within the range [1…30]

// GALILEO-Specific data

i2 iod; // Issue of almanac data [] 

u1 cs; // Checksum 

}; 

[QA] QZSS Almanac 

struct QZSSAlm {47} {

// GPS-alike data

GPSAlm gps; // ‘gps.sv’ within the range [193…197]

}; 

[CA] BeiDou Almanac 

struct BeiDouAlm {47} {

// GPS-alike data

GPSAlm gps; // ‘gps.sv’ within the range [1…30]

}; 

[IA] IRNSS Almanac 

struct IrnssAlm {47} {

// GPS-alike data

GPSAlm gps; // ‘gps.sv’ within the range [1…30]

}; 

GREIS www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Almanacs and Ephemeris 

[NA] GLONASS Almanac 

struct GLOAlmanac {47 | 52} {
u1 sv; // Satellite orbit slot number within [1…32] []
i1 frqNum; // Satellite frequency channel number [-7…24] []
i2 dna; // Day number within 4-year period starting 

// with the leap year [] 
f4 tlam; // Time of the first ascending node passage 
// on day ‘dna’ [s] 

u1 flags; 
// Satellite flags [bitfield]: 
// 0 - health: 1 - healthy SV, as specified 
// by ‘Cn’, 0 - unhealthy 
// 1 - SVs type: 0 - GLONASS, 1 - GLONASS-M 
// 2…7 - reserved 

//======= Clock data =======
f4 tauN; // Coarse time correction to SV clock// with respect to GLONASS system time [s]
f8 tauSys; // Correction to GLONASS system time with respect

// to UTC(SU) [s]
//===== Ephemeris data =====
f4 ecc; // Eccentricity at reference time ‘tlam’ []
f4 lambda; // Longitude of ascending node

// at reference time ‘tlam’ [semi-circles]
f4 argPer; // Argument of perigee// at reference time ‘tlam’ [semi-circles] 
f4 delT; // Correction to mean Draconic period

// at reference time ‘tlam’ [s/period]
f4 delTdt; // Rate of change of Draconic period [s/period^2]
f4 deli; // Correction to inclination

// at reference time ‘tlam’[semi-circles] 
u1 n4; // Number of 4-year period []
// --- Optional data block --
u1 reserved; // <reserved>
f4 gammaN; // Rate of coarse satellite clock correction to

// GLONASS time scale [s/s]
// --- End of optional data block --
u1 cs; // Checksum 


}; 

[WA] SBAS Almanac 

struct SBASAlmanac {51} {
u1 waasPrn; // SBAS SV PRN number within [120…142] 

u1 gpsPrn; 
u1 id; 
u1 healthS; 


u4 tod; 
f8 xg, yg, zg; 
f4 vxg, vyg, vzg; 
u4 tow; 
u2 wn; 
u1 cs; 


}; 

// GPS SV PRN associated with SBAS SV 
// Data ID 
// Satellite health [bitfield]:
// 0 - 0–Ranging on, 1–off 
// 1 - 0–Corrections on, 1-off 
// 2 - 0–Broadcast Integrity on, 1-off 
// 3 - reserved 
// 4…7 - are set to zero 
// Time of the day [s] 
// ECEF coordinates [m] 
// ECEF velocity [m/s] 
// time of GPS week almanac was received at 
// GPS week this almanac was received at 
// Checksum 

100 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Almanacs and Ephemeris 

[GE] GPS Ephemeris 

struct GPSEphemeris {123 | 160 | 168} {
GpsEphReqData req; // Required data
GpsEphOptData opt; // Optional data. Present when length > 123.
u1 cs; // Checksum 


}; 

struct GpsEphReqData {122} {
u1 sv; // SV PRN number within the range [1…37] 
u4 tow; // Time of week [s]
u1 flags; // Flags (see GPS ICD for details)[bitfield]:


// 0 - curve fit interval 
// 1 - data flag for L2 P-code// 2,3 - code on L2 channel// 4 - anti-spoof (A-S) flag (from HOW) 
// 5 - ‘Alert’ flag (from HOW) 

// 6 - ephemeris was retrieved from non-volatile memory 

// 7 -reserved 
//===== Clock data (Subframe 1) =====
i2 iodc; // Issue of data, clock [] 
i4 toc; // Clock data reference time [s] 
i1 ura; // User range accuracy [] 
u1 healthS; // Satellite health [] 
i2 wn; // Week number [] 
f4 tgd; // Estimated group delay differential [s] 
f4 af2; // Polynomial coefficient [s/(s^2)] 
f4 af1; // Polynomial coefficient [s/s] 
f4 af0; // Polynomial coefficient [s]
//===== Ephemeris data (Subframes 2 and 3) =====
i4 toe; // Ephemeris reference time [s] 
i2 iode; // Issue of data, ephemeris []
//--- Keplerian orbital parameters --
f8 rootA; // Square root of the semi-major axis [m^0.5] 
f8 ecc; // Eccentricity [] 
f8 m0; // Mean Anomaly at reference time (wn,toe)


// [semi-circles] 
f8 omega0; // Longitude of ascending node of orbit plane at the 

// start of week ‘wn’ [semi-circles] 
f8 inc0; // Inclination angle at reference time [semi-circles] 
f8 argPer; // Argument of perigee [semi-circles]
//--- Corrections to orbital parameters --
f4 deln; // Mean motion difference from computed value

// [semi-circle/s]
f4 omegaDot; // Rate of right ascension [semi-circle/s]
f4 incDot; // Rate of inclination angle [semi-circle/s] 
f4 crc; // Amplitude of the cosine harmonic correction term

// to the orbit radius [m] 
f4 crs; // Amplitude of the sine harmonic correction term// to the orbit radius [m] 
f4 cuc; // Amplitude of the cosine harmonic correction term// to the argument of latitude [rad] 
f4 cus; // Amplitude of the sine harmonic correction term

// to the argument of latitude [rad] 
f4 cic; // Amplitude of the cosine harmonic correction term
// to the angle of inclination [rad] 


f4 cis; // Amplitude of the sine harmonic correction term
// to the angle of inclination [rad] 
}; 


GREIS www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Almanacs and Ephemeris 

struct GpsEphOptData {37 | 45} {

u1 navType; 
// Signal type [bitfield]
// 0 - L1 NAV 
// 1 - L2C CNAV 
// 2 - L5 CNAV 
// 3 - L1C CNAV2 


i4 lTope; // Time of prediction for ephemeris data 
i4 lTopc; // Time of prediction for clock data 
f8 dADot; // Change rate in semi-major axisf4 fDelnDot; // Rate of mean motioni1 cURAoe; // SV ephemeris URA index 
i1 cURAoc; // SV clock URA index 
i1 cURAoc1; // SV clock URA change index 
i1 cURAoc2; // SV clock URA change rate index 
f4 fIscL1CA; // Inter-signal correction between L1P(Y) and L1 C/Af4 fIscL2C; // Inter-signal correction between L1P(Y) and L2C
f4 fIscL5I5; // Inter-signal correction between L1P(Y) and L5I5f4 fIscL5Q5; // Inter-signal correction between L1P(Y) and L5Q5
f4 fIscL1CP; // Inter-signal correction between L1P(Y) and L1CPf4 fIscL1CD; // Inter-signal correction between L1P(Y) and L1CD
f4 DAf0; // correction to ‘af0’. Exact term = af0 + DAF0 

}; 

[EN] GALILEO Ephemeris 

struct GALEphemeris {149} {
GpsEphReqData req; // GPS required data, ‘req.sv’ within the range [1…30]
// --- GALILEO-specific data block --
f4 bgdE1E5a; // broacast group delay E1 - E5A [s]
f4 bgdE1E5b; // broacast group delay E1 - E5B [s]
f4 ai0; // Effective ionisation level 1-st order parameter [] 
f4 ai1; // Effective ionisation level 2-nd order parameter [] 
f4 ai2; // Effective ionisation level 3-rd order parameter [] 
u1 sfi; // Ionospheric disturbance flags [bitfield]
u1 navType; // Signal type [bitfield]:

// 0 - GALILEO E1B(INAV) 
// 1 - GALILEO E5A(FNAV) 
// 2 - GALILEO E5B(INAV) 
// 3 - GIOVE E1B (historical) 
// 4 - GIOVE E5A (historical) 
// 5 - <reserved> 
// 6 - GALILEO E6 

f4 DAf0; // correction to ‘af0’. Exact term = af0 + DAF0// --- End of GALILEO-specific data block --
u1 cs; // Checksum 

}; 

102 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Almanacs and Ephemeris 

[QE] QZSS Ephemeris 

struct QZSSEphemeris {123 | 160} {
GPSEphemeris gps; // Without ‘cs’, ‘gps.sv’ within the range[193…197]
u1 cs; // Checksum 

}; 

[CN] BeiDou Ephemeris 

struct BeiDouEphemeris {132} {
GpsEphReqData req; // GPS required data, ‘req.sv’ within the range [1…30]
// --- BeiDou-specific data block --
f4 tgd2; //
u1 navType; // Signal type[bitfield]

// 0 - B1 
// 1 - B2 
// 2 - B3 


f4 DAf0; // correction to ‘af0’. Exact term = af0 + DAF0
// --- End of BeiDou-specific data block --
u1 cs; // Checksum 


}; 

GREIS www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Almanacs and Ephemeris 

[NE] GLONASS Ephemeris 

struct GLOEphemeris {88 | 103} {
! u1 sv; // Satellite orbit slot number [1…32] []
i1 frqNum; // Satellite frequency channel number [-7…24] []

! i2 dne; // Day number within 4-year period [] 
i4 tk; // Frame start time within current day [s] 
i4 tb; // Ephemeris reference time (for day ‘dne’) [s]
u1 health; // Satellite health [bitfield] 

// 0 - MSB taken from Bn word which indicates 
// satellite health: 
// 1 - satellite is unhealthy 
// 0 - satellite is healthy 
// 1 - If set, this flag indicates that params 
// ‘tau’ and ‘gamma’ may be wrong 
// (Note that receiver performs several 
// ‘internal’ data consistency checks allowing 
// detection of problem broadcast parameters) 
// 2 - If set, this flag indicates that initial 
// conditions ‘r[3]’ and ‘v[3]’ may be wrong 
// 3 - SV health (Cn word) status from almanac: 
// 0 - satellite is unhealthy 
// 1 - satellite is healthy 
// 4 - If set, this flag indicates that SV health 
// status from almanac is available 
// 5…7 - reserved 

//===== Ephemeris data ======
u1 age; // Age of operational information (En) [days] 
u1 flags; // Flags (for details, see GLONASS ICD) [bitfield]:


// 0…1 - p1 word 
// 2 - p2 word 
// 3 - p3 word 
// 4…5 - 2 LSB taken from Bn word 
// 6 - ephemeris was retrieved from NV-memory 
// 7 - SV is GLONASS-M or newer 

f8 r[3]; // Satellite PE-90 coordinates [km] 
f4 v[3]; // Satellite PE-90 velocities [km/s] 
f4 w[3]; // Satellite PE-90 accelerations due to Luni-Solar 


// gravitational perturbations [km/s^2]
//===== Clock data ======
f8 tauSys; // Time correction to GLONASS time scale (vs. UTC(SU))
// tauSys = TUTC(SU) - TGLN [s] 
f4 tau; // Correction to satellite clock (vs. GLONASS time) 
// tau = TGLN - TSV [s] 
f4 gamma; // Rate of satellite clock offset [s/s]

//===== GLONASS-M data ======
f4 fDelTauN; // Delta Tau N - delay between L1 and L2 [s]
u1 nFt; // Ft (User Range Accuracy), see GLONASS ICD for values 
u1 nN4; // Number of 4-year cycle [1…31]
u2 flags2; // Flags (for details, see GLONASS ICD) [bitfield]:

// 0 - GLONASS-M ln (third string) 
// 1…2 - GLONASS-M P 
// 3 - GLONASS-M P4 
// 4…5 - GLONASS-M M 
// 6 - GLONASS-M ln (fifth string) 
// 7…15 - reserved 

104 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Almanacs and Ephemeris 

// --- Optional data block --


u1 navType; // Signal type [bitfield]
// 0 - L1 
// 1 - L3 
// 2 - L2C 
// 3 - P1 
// 4 - P2 


f4 beta; // Derivation of rate of satellite clock offset [s/s/s]
f4 tauSysDot; // Derivation of ‘tauSys’ [s/s]
u1 ec; // Age of clock information (days) 
u1 ee; // Age of ephemeris information (days) 
i1 fc; // Clock accuracy index 
i1 fe; // Ephemeris accuracy index 
u2 reserv;
// --- End of optional data block --
u1 cs; // Checksum 


}; 

[WE] SBAS Ephemeris 

struct SBASEhemeris {73} {
u1 waasPrn; // SBAS SV PRN number within [120…142] 
u1 gpsPrn; // GPS SV PRN associated with SBAS SV 
u1 iod; // Issue of data 
u1 acc; // SBAS SV accuracy7 
u4 tod; // Reference time (seconds of the day)[s] 
f8 xg, yg, zg; // ECEF coordinates [m] 
f4 vxg, vyg, vzg; // ECEF velocity [m/s]
f4 vvxg, vvyg, vvzg; // ECEF acceleration [m/s^2]
f4 agf0; // SBAS SV clock offset factor ‘ao’ [s] 
f4 agf1; // SBAS SV clock offset factor ‘a1’ [s/s] 
u4 tow; // Time of GPS week this ephemeris was 


// received at 
u2 wn; // GPS week this ephemeris was received at 
u2 flags; // Flags [bitfield]:

// 0…5 - reserved 
// 6 - ephemeris was retrieved from NV-memory 
// 7…15 - reserved 

u1 cs; // Checksum 
}; 


[IE] IRNSS Ephemeris 

struct IrnssEphemeris {124} {
// GPS-alike data
GPSEphemeris gps; // Without ‘cs’, ‘gps.sv’ within the range[1…7]
u1 navType; // Signal type [bitfield]


// 0 - L5 
u1 cs; // Checksum 
}; 


7. For details, see ICD-GPS-200C, Revision IRN-200C-004 April 12, 2000. 
GREIS www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Raw Navigation Data 

3.4.8 Raw Navigation Data 
Most raw navigation data messages have the errCorr field, which meaning is as follows: 


Values Meaning 
-128 Error(s) have been detected and left uncorrected due to user settings. See 
/par/raw/data/mode parameter 
[-127…0] Data check algorithm detected this number of errors, but error recovery is not 
available or had failed 
0 No errors detected 
[1…127] This many errors have been detected and corrected 

[gd] GPS Raw Navigation Data 

struct GpsRawNavData {len*4+9} {
u1 prn; // Pseudo-Range Number (PRN) 
u4 time; // Time of receiving of message [s] 
u1 type; // Type of data:


// 0 - L1 NAV 
// 1 - L2C CNAV 
// 2 - L5 CNAV 
// 3 - L1C CNAV2 


u1 len; // Length of the navigation data block ‘data’
u4 data[len]; // Navigation data block
i1 errCorr; // Error corrections
u1 cs; // Checksum


}; 

In the data field of the message, when type field is set to L1, every element contains 30 
LSBits of navigation data; when type field is set to anything else, all 32 bits are used. 
The most significant bit corresponds to the first broadcast symbol. 

[qd] QZSS Raw Navigation Data 

struct QzssRawNavData {len*4+8} {
GpsRawNavData data;
}; 


[lD] GLONASS Raw Navigation Data 

struct GloRawNavData {len*4+10} {
! u1 num; // SV number 
! i1 fcn; // SV frequency code number 


u4 time; 
// GLONASS time of receiving of message [s] 

u1 type; 
// Type of data:
// 0 - L1 
// 1 - L3 
// 2 - L2C 


106 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Raw Navigation Data 

// 3 - P1 

// 4 - P2 
u1 len; // Length of the navigation data block ‘data’
u4 data[len]; // Navigation data block
i1 errCorr; // Error corrections
u1 cs; // Checksum 


}; 

In the data field of the message, when type field is set to L1, every element contains 25 
LSBits of the string of GLONASS sub-frame; when type field is set to L3, all 32 bits are 
used. The most significant bit corresponds to the first broadcast symbol. 

[WD] SBAS Raw Navigation Data 

struct SbasRawNavData {41} {
u1 prn; // SV PRN number within the range [120…142] 
u4 time; // Time of receiving of message [s] 
u1 type; // Type of data:


// 0 - L1 CA (NAV) 

// 1 - L5 
u1 len; // Length of the navigation data block ‘data’
u1 data[32]; // Navigation data block
i1 errCorr; // Error corrections 
u1 cs; // Checksum 


}; 

In the data field of the message the most significant bit of the first byte corresponds to 
the first broadcast 4-ms data symbol. The field contains data starting from SBAS preamble 
up to and including SBAS checksum. 

[ED] GALILEO Raw Navigation Data 

struct GalRawNavData {len+9} {
u1 prn; // SV PRN number within the range [1…30] 
u4 time; // Time of receiving of message [s] 
u1 type; // Type of data:


// 0 - GALILEO E1B(INAV) 
// 1 - GALILEO E5A(FNAV) 
// 2 - GALILEO E5B(INAV) 
// 3 - GIOVE E1B (historical) 
// 4 - GIOVE E5A (historical) 
// 5 - <reserved> 
// 6 - GALILEO E6 

u1 len; // Length of the navigation data block ‘data’
u1 data[len]; // Navigation data block
i1 errCorr; // Error corrections
u1 cs; // Checksum


}; 

In the data field of the message the most significant bit of the first byte corresponds to 
the first broadcast symbol. 

GREIS www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Raw Navigation Data 

For INAV, the datafield of the message contains no sync bits, and has the following layout: 


Table 3-10. INAV Raw Data Layout 

# Field Name Field Length [bits] 
1 even/odd 1 
2 page type 1 
3 Data (1/2) 112 
4Tail 6 
5 even/odd 1 
6 page type 1 
7Data (2/2) 16 
8 Reserved 1 1 
9 CRC 24 
10 Reserved 2 8 
11 Tail 6 

For FNAV, the data field of the message contains no sync bits, and has the following 
layout: 

Table 3-11. FNAV Raw Data Layout 

# Field Name Field Length [bits] 
1 page type 6 
2 nav data 208 
3crc 24 
4tail 6 

For GIOVE-E1B, the data field of the message contains navigation data starting from 
the “Res-1” field up to and including the “Tail” field. 

[cd] BeiDou Raw Navigation Data 

struct CompRawNavData {len*4+9} {
u1 prn; // SV PRN number 
u4 time; // BeiDou Time of receiving of message [s] 
u1 type; // Type of data:


// 0 - B1 
// 1 - B2 
// 2 - B3 
// 3 - B1 from GEO 
// 4 - B2 from GEO 
// 5 - B3 from GEO 
// 6 - B1C 
// 7 - B1-2 


108 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Obsolete Raw Navigation Data 

// 8 - B5A 

// 9 - B5B 
u1 len; // Length of the navigation data block ‘data’u4 data[len]; // Navigation data blocki1 errCorr; // Error correctionsu1 cs; // Checksum 

}; 

[id] IRNSS Raw Navigation Data 

struct IrnssRawNavData {len*4+9} {
u1 prn; // SV PRN number 
u4 time; // IRNSS time of receiving of message [s] 
u1 type; // Type of data: 

// 0 - L5 
u1 len; // Length of navigation data block ‘data’u4 data[len]; // Navigation data blocki1 errCorr; // Error correctionsu1 cs; // Checksum

}; 

3.4.9 Obsolete Raw Navigation Data 
[GD] GPS Raw Navigation Data (obsolete) 

Note: This format is obsolete. Use [gd] message instead. 

struct GpsNavData {N*recSize+2} {
u1 recSize; // Size of satellite data record (currently 42)
SvData dat[N]; // Satellite data. “N” can be derived from the 

// following expression:
// N=([Message Length] - 2) / recSize) 
u1 cs; // Checksum 
}; 

struct SvData {recSize} {
i1 prn; // Pseudo-Range Number (PRN) 
u1 cnt; // Counter which is updated upon receiving a

// new sub-frame for given satellite. 
u4 data[10]; // GPS sub-frame contents. Every 4-bytes word// contains 30 LSB of the GPS navigation data. 
}; 

When decoding this message it’s essential to remember the value of the cnt field of the 
last received data block for every satellite and ignore consecutive sub-frames with 
matching value of the cnt field, if any. 

[QD] QZSS Raw Navigation Data (obsolete) 

Note: This format is obsolete. Use [qd] message instead. 

GREIS www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Spectrum Messages 

struct QzssNavData {N*recSize+2} {
GpsNavData data; 
}; 


[LD] GLONASS Raw Navigation Data (obsolete) 

Note: This format is obsolete. Use [lD] message instead. 

struct GloNavData {N*recSize+2} {
u1 recSize; // Size of satellite data record (currently 18)
SvData dat[N]; // Satellite data. “N” can be derived from the 

// following expression:
// N=([Message Length] - 2) / recSize) 
u1 cs; // Checksum 
}; 

struct SvData {recSize} {
i1 fcn1; // Frequency Channel Number plus 1(FCN+1) 
u1 cnt; // Counter which is updated upon receiving a

// string of a GLONASS sub-frame for given FCN. 
u4 data[4]; // GLONASS string contents. Every 4-bytes word contains// 25 LSB of the string of GLONASS sub-frame. 
}; 

When decoding this message it’s essential to remember the value of the cnt field of the 
last received data block for every satellite and ignore consecutive sub-frames with 
matching value of the cnt field, if any. 

3.4.10 Spectrum Messages 
In the spectrum messages, ‘n’ denotes the number of spectra. It depends on receiver 
type and is equal to the number of RF bands implemented in the receiver. The order of 
particular set of spectra always matches those of the following list: 

GPS L1, GPS L2, GPS L5, GLONASS L1, GLONASS L2, GALILEO E5B 

For example, single-frequency GPS/GLONASS receiver will have 2 spectra, GPS L1, 
and GLONASS L1, in this particular order. 

Refer to “Spectrum Parameters” on page 474 for more information 

[sp] Spectrum 

struct Spectrum {n*m*2+7} {
i2 currFrq; // Current frequency [Hz*104]
i2 finalFrq; // Frequency of the last message [Hz*104]
u1 n; // Number of spectra in this 
u1 m; // Number of spectrum blocks in this message 
SpecData s[m]; // Spectrum data 
u1 cs; // Checksum 

}; 

110 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Hardware Calibrator Messages 

struct SpecData {2*n} {
i2 spec[n]; // Spectrum values for n spectra [dB*0.1]
}; 


[sP] Extended Spectrum 

struct Spectrum {n*m*4+7} {
i2 currFrq; // Current frequency [Hz*104]
i2 finalFrq; // Frequency of the last message [Hz*104]
u1 n; // Number of spectra in this message 
u1 m; // Number of spectrum blocks in this message 
ExtSpecData s[m]; // Extended spectrum data 
u1 cs; // Checksum 


}; 

struct ExtSpecData {4*n} {
i2 spec[n]; // Spectrum values for n spectra [dB*0.1]
u1 agcmin[n]; // Min AGC values []
u1 agcmax[n]; // Max AGC values []


}; 

[ms] Modem Spectrum 

struct MDM_Spectrum {9} {
i4 frq; // Current frequency [Hz]
i4 pwr; // Current signal (or noise) power [dBm]
u1 cs; // Checksum


}; 

3.4.11 Hardware Calibrator Messages 
Messages described in this section contain measurements obtained by the hardware calibrator 
(refer to “Hardware Calibrator” on page 209). 

[gC], [g1], [g2], [g3]: GLONASS Delays 



struct GloDelays {9*nFcn+1} {
SvDelay del[nFcn]; // Delays
u1 cs; // Checksum 


}; 

struct SvDelay {9} {
i1 fcn; // GLONASS FCN[-7…6]
f4 phase; // Phase delay [cycles]
f4 range; // Range delay [s]


}; 

The [gC], [g1], [g2], and [g3] messages contain CA/L1, P/L1, P/L2, and CA/L2 phase 
and code delays for GLONASS FCNs. 

GREIS www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

ADU Messages 

[gR]: Code Delays of Receiver RF Bands 


struct CalBandsDelay {6*n+1} {
BandDelay d[n]; // n may vary depending on receiver model
u1 cs; // Checksum 
}; 

struct BandDelay {6} {
i1 band; // 0-gps1, 1-gps2, 2-gps5, 3-glo1, 4-glo2, 5-glo3
i1 signal; // 0-ca, 1-p
f4 delay; // Code delay [s] 

}; 


3.4.12 ADU Messages 
[MR] Rotation Matrix 

struct RotationMatrix {37} {
u4 time; // receiver time [ms]
f4 q00, q01, q02, q12; // components of the rotation matrix Q []
f4 rms[3]; // estimated accuracy for three baseline vectors [m]
u1 solType[3]; // solution type8 for three baseline vectors 
u1 flag; // 0 – components of matrix Q are invalid, 1 - valid 
u1 cs; // Checksum 

}; 

[mr] Rotation Matrix and Vectors 

struct RotationMatrixAndVectors {73} {
u4 time; // receiver time [ms]
f4 q00, q01, q02, q12; // components of the rotation matrix Q []
f4 rms[3]; // estimated accuracy for three baseline vectors [m]
u1 solType[3]; // solution type8 for three baseline vectors 
u1 flag; // 0 – components of matrix Q are invalid, 1 - validf4 bl0[3]; // baseline vector M-S0 in the current epoch[m]
f4 bl1[3]; // baseline vector M-S1 in the current epoch[m]
f4 bl2[3]; // baseline vector M-S2 in the current epoch[m]
u1 cs; // Checksum 

}; 

[AR] Rotation Angles 

struct RotationAngles {33} {
u4 time; // Receiver time [ms] 
f4 p,r,h; // Pitch ,roll , heading angles [deg] 
f4 sp,sr,sh; // Pitch, roll, heading angles RMS[deg]
u1 solType[3]; // Solution type for 3 base lines
u1 flags; // flags [bitfield]:


// 0: 0 - no data available 

8. See Table 3-3, “Solution Types,” on page 66 
112 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

ADU Messages 

// 1 - data are valid 
// 7…1: reserved 
u1 cs; // Checksum 
}; 


[AV] Angular Velocities 

struct AngularVelocity {22} {
u4 time; // receiver time [ms] 
f4 x; // X component of angular velocity [rad/s] 
f4 y; // Y component of angular velocity [rad/s] 
f4 z; // Z component of angular velocity [rad/s] 
f4 rms; // Angular velocity RMS [rad/s]
u1 flags; // flags [bitfield]: 


// 0: 0 - no data available 
// 1 - data are valid 
// 7…1: reserved 


u1 cs; // Checksum 
}; 


This message contains angular velocities in WGS-84. 

[IM] Inertial Measurements 

struct InertialMeasurements {25} {
f4 accelerations[3]; // ax,ay,az [m/sec2]
f4 angularVelocities[3]; // wx,wy,wz [rad/sec] 
u1 cs; 


}; 

This meassage contains measurements from the IMU converted into physical units with 
compensated misalignments, scale factors, and temperature drift. The measurements are 
provided in the local coordinate system. 

[MA] Accelerometer and Magnetometer Measurements 

struct AccMag {38} { 
u4 time; // receiver time [ms]
f4 accelerations[3]; // ax, ay, az [cm/sec2]
f4 induction[3]; // bx, by, bz 
f4 magnitude; // Value of magnetic field 
f4 temperature; // Temperature of magnetic sensor [deg C] 
u1 calibrated; // 1 - calibrated, 0 - not calibrated 
u1 cs; // Checksum 


}; 

This message contains compensated measurements from accelerometer and magnetometer. 


GREIS www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Event Marker and PPS Messages 

3.4.13 Event Marker and PPS Messages 
The event marker and PPS have their own reference time settings governed by corresponding 
parameters9. As a consequence, some of the event marker and PPS messages 
described below utilize the “time scale” field of the following format: 

Table 3-12. Event Marker and PPS time scale 

Value Description 
0 GPS system time 
1 UTC(USNO). Universal Coordinated Time supported by the U.S. Naval Observatory 
2 GLONASS system time 
3 UTC(SU). Universal Coordinated Time supported by the State Time and Frequency 
Service, Russia 
4 SBAS system time 
5 UTC SBAS 
6 GALILEO system time 
7 UTC GALILEO 
8 BeiDou system time 
9 UTC BeiDou 
10 QZSS system time 
11 UTC QZSS 
12 IRNSS system time 
13 UTC IRNSS 
14…255 Reserved 

[XA], [XB] External Event 

struct ExtEvent {10} {
i4 ms; // ms part of event time tag 
i4 ns; // ns part of event time tag
u1 timeScale; // time scale
u1 cs; // Checksum 


}; 

The event time tag is the time in corresponding time scale modulo one day. 

To make your receiver generate these messages, you additionally need to turn on external 
event processing on corresponding external event input (using 
/par/dev/event/[a|b]/in parameters). 

9. /par/dev/event/[a|b]/time, and /par/dev/pps/[a|b]/time 
114 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Heading and Pitch Messages 

[ZA], [ZB] PPS Offset 

struct PPSOffset {5} {

f4 offs; // PPS offset in nanoseconds

u1 cs; // Checksum 

}; 

Due to a hardware limitation, PPS signals are discrete with resolution that depends on 
particular receiver model. JAVAD GNSS receiver allows you to compensate for this discreteness 
error by means of utilizing this message. It contains the offset between the 
scheduled PPS time and the actual pulse edge's arrival time. When the pulse edge is earlier 
than the scheduled time, the offset is positive. When the pulse edge is delayed relative 
to the scheduled time, the offset is negative. 

[YA], [YB] Time Offset at PPS Generation Time 

struct RcvTimeOffsAtPPS {10} {

f8 offs; // [Tpps-Tr] offset[s]

u1 timeScale; // time scale

u1 cs; // Checksum 

}; 

This message contains PPS reference time to receiver time offset at the moment of PPS 
generation. 

PPS is usually output before solution for given epoch is ready, and therefore clock offset 
is extrapolated from those computed at previous epoch. It’s this clock offset that is output 
in this message and that is why it could be slightly different than those output in 
messages such as [TO]. 

3.4.14 Heading and Pitch Messages 
[ha] Heading and Pitch 

struct HeadAndPitch {10} {

f4 heading; // Heading of the baseline between the base and the

// rover receiver [degrees] 

f4 pitch; // Pitch of the baseline between the base and the

// rover receiver [degrees]

u1 solType; // Solution type

u1 cs; // Checksum 

}; 

This message contains heading and pitch calculated by the RTK engine. 

GREIS www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Integrated Messages 

[RO] Lever Arm Cartesian Position 

This message contains the position of the master antenna corrected by the rotated lever 
arm vector. It has exactly the same format as the [PO] message described on page 74. 

[RG] Lever Arm Geodetic Position 

This message contains the position of the master antenna corrected by the rotated lever 
arm vector. It has exactly the same format as the [PG] message described on page 75. 

3.4.15 Integrated Messages 
Warning: 
Integrated messages are supported for backward compatibility only. No new features 
(systems, signals, etc.) will be added to these formats due to their limited flexibility. 
Please consider to use generic standard messages instead. 

For the users that prefer to have different yet logically related data in a single message, 
the JAVAD GNSS receiver supports a set of integrated messages. For example, the message 
[rM] may contain all of the code and carrier phase measurements available in the 
receiver for the given epoch, though this is achieved in exchange for much more complex 
internal message structure. Integrated messages are also somewhat optimized for 
real-time applications, so we also sometimes call them “real-time messages”. The exact 
contents of these messages are defined by corresponding receiver parameters10 that are 
not local to particular output stream. It means that using the integrated messages, one 
can’t have different variants of these messages to be enabled to be output to different 
output streams simultaneously. 

In the integrated messages, the field “sample” serves two main purposes. First, it allows 
the user to preserve data integrity since messages referenced to a specific epoch will all 
have the same sample number. Second, this field allows the user to keep track of the 
number of lost messages issued through a given port since the sample number is incremented 
when the next epoch starts. 

Integrated messages can be received by the user in an arbitrary order of precedence. 
Before decoding a message its CRC16 checksum must be checked. Remember that the 
checksum is computed for all the bytes starting from the first byte of the header of the 
message up to but not including the checksum itself (for more information about CRC16 
algorithm, please refer to “Computing CRC16” on page 495). 

The following tables, which are given for user reference, will explain the relationships 
between the integrated messages, [rE], [rM], [rV], and the basic JPS messages. 

10. See “Parameters of Integrated GREIS Messages” on page 339. 
116 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Integrated Messages 

[rM] can be used in place of the following messages: 

Pseudo-range measurements [RC], [rc], [R1], [r1], [1R], [1r], 
[R2], [r2], [2R], [2r] 
Carrier Phase measurements [PC], [pc], [CP], [cp], [P1], [p1], 
[1P], [1p], [P2], [p2], [2P], [2p] 
Doppler [DC], [D1], [D2] 
Signal Lock Loop Flags [FC], [F1], [F2] 
Carrier to Noise ratio [EC], [E1], [E2] 
Satellite navigation status [SS] 
Satellite Indices [SI] 
GLONASS Satellite System Numbers [NN] 
Receiver Date and Receiver Time [RD], [~~] 
Time since Last Loss-of-Lock1 [TC] 
Receiver Reference Time to Receiver Time Offset2 [TO] 

1. Note that there is a limitation on the maximum tracking time reported in [rM] (102.3 seconds). 
2. Remember that there is a limitation on the clock offset resolution (125 ns). 
[rV] can be used in place of the following messages: 

Position/Velocity messages [PO], [VE], [PV] 
Solution time tag [ST] 

[rE] can be used in place of the following messages: 

Receiver Date and Receiver Time [RD], [~~] 
You can govern the structure of your [rM] message by means of parameters from section 
“Parameters of Integrated GREIS Messages” on page 339. Also note that the format of 
[rM] allows addition of new fields to the structure if necessary. 

In the event of new fields showing up in the message, its version number is incremented 
of course. Note that lengths of the structures “Header” and “SlotRec” are specified in the 
message explicitly, which makes it possible to maintain backward compatibility with 
any older software using the message. 

The message [rE], which was conceived as a time tag for any other message type, is 
reserved for future use. The field “sample”, which will exist in any integrated message, 
is intended to maintain data integrity, i.e., all messages associated with a given epoch 
must have identical “sample” numbers. 

GREIS www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Integrated Messages 

[rE] Reference Epoch 

struct RefEpoch {10} {

u2 sample; // Sample number [dimensionless] 

u2 scale; // Time scale ID, leap second status and

// week/day part of epoch representation [bitfield]

// 15…13: time scale ID: 

// 0 – GPS, 1 – GLONASS, 2 – UTC; 

// 12…11: leap second status: 

// 0 – no leap second epoch; 

// 1 – positive leap second; 

// 2 – negative leap second; 

// 3 – leap second status is unknown; 

// this flag shows whether a leap second 

// occurred at the current epoch; 

// 10…0: week/day representation: 

// (a) if time scale ID is GPS: 

// week number [0…1023], 

// 1024 indicates unknown week number; 

// (b) if time scale ID is GLONASS: 

// day number within 4-year period [1…1461], 

// 0 indicates unknown day number 

// (c) if time scale ID is UTC: 

// day number within the year [1…366], 

// 0 indicates unknown day number;

u4 reftime; // Milliseconds part of epoch representation [ms]:

// (a) if time scale ID is GPS: 

// milliseconds of GPS week; 

// (b) if time scale ID is GLONASS: 

// milliseconds of GLONASS day; 

// (c) if time scale ID is UTC, 

// milliseconds of UTC day; 

u2 crc16; // 16-bit CRC 

}; 

[rM] Raw Measurements 

struct RawMeas {N*((14|10|6)*M+6)+14} {

u2 sample; // Sample number [] 

u2 scale; // See [rE] for description 

u4 reftime; // See [rE] for description 

i2 clock; // Clock offset:

// 15…2: Clock offset 

// -213 /+(213-1) [125 nanoseconds]: 

// 1…0: Clock offset ID: 

// 0 – clock offset is unavailable 

// 1 – [GPS - Receiver time] 

// 2 – [GLONASS - Receiver time] 

// 3 - reserved 

u2 flags; // Flags [bitfield]: 

// 15…13: message version [0…7] 

// 12…8: total number of “svd” records (N) 

// 7…5: this value plus 6 makes the length 

// of the structure “Header” in bytes 

// 4…0: this value plus 10 (for “version” 0 and 1), 

// or 6 (for “version” [2…7]) makes the length 

118 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Integrated Messages 

// of the structure “SlotRec” in bytes
SvData svd[N]; // SVs data (see below)
u2 crc16; // 16-bit CRC 


}; 

struct SvData {(14|10|6)*M+6} {
Header header; // Header (see below) 
SlotRec slot[M]; // Slot records (see below) 


}; 

struct Header {6} {
u4 refrange; // Reference pseudo-range [0.02 meters] 
u1 usi; // USI (see [SI] message) 
u1 num; // Number of slot records (M) [bitfield]: 


// 7…3: reserved 
// 2…0: number of slot records minus one (M) 
}; 


struct SlotRec {14|10|6} {
// Note: The zeroth element of the array Slot[i],i=0,…,M-1, 
// unlike the other elements, does not contain corrections 
// to the reference pseudo-range from the Header structure.
// To provide the user with additional information, the flag
// ‘svst’ is used for ‘delrange’ in the zeroth slot.
i2 svstOrDelrange; // SV status [bitfield], or 


// Delta pseudo-range [0.02 meters].
// SV status [bitfield]:
// 15…11: GLONASS slot number (for GPS SV the field 
// is undefined), [0…32], 0 - unknown 
// 10…6: Channel number [0…31], 31 - unavailable 
// 5…0: Satellite navigation status// Delta pseudo-range [0.02 meters]:
// [full pseudo-range for given slot]-[refrange]

u4 word1; // Packed data 1 [bitfield]:
// 31…12: [carrier phase] - [refrange] 
// [-219…(219-1)] [0.0005 meters] 
// 11…9: slot ID: 
// 0 - C/A L1; 1 - P1; 2 - P2; 3 - C/A L2; 
// 4 - L5; 5,6,7 - reserved 
// 8: reserved 
// 7: signal lock loop flags are available 
// 6: lock time is available 
// 5…0: Signal-to-noise ratio [dB*Hz]

u2 flags; // Signal lock loop flags (see [FC] message)

u2 lock; 
// Packed data 2 [bitfield]:
// 15…12: fractional part of Signal-to-noise 
// ratio [0.1 dB*Hz] 
// 11…10: reserved 
// 9…0: lock time [0.1 second]. Tracking time since 
// last loss of lock. Varies between 0 and 
// 102.3 seconds. “Gets stuck” at 102.3s after 
// the actual tracking time exceeds this value 
// (until another loss of lock occurs).

u4 word2; // Packed data 3. Only present for “version” 0 [bitfield]:
// 31…7: Doppler [-224…(224-1)], [0.001 Hz] 
// 6…0: reserved 

}; 

When handling [rM] message, the following rules must be observed: 

GREIS 
www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Integrated Messages 

1. 
The user should retrieve from the message its version number and the lengths of 
the structures Header and SlotRec. These fields are necessary to maintain compatibility 
with older software in case the message structure is modified in the 
future. At present, there are three versions, 0, 1, and 2. Versions 1 and 2 are 
intended for RTK applications. In version 1, the field word2 is removed from the 
structure SlotRec altogether, which results in a more compact data set as compared 
against version 0. In version 2, the fields flags, lock, and word2 are 
removed from the structure SlotRec. 
2. 
Next, the user should retrieve the “total number of svd records” field. Although 
it is possible to decode the message by using the message length from the message’s 
header, taking into account the “total number of svd records” field simplifies 
the decoding. 
3. 
Field refrange from the structure SvData serves as a reference for all the other 
code and carrier phase measurements available for the given satellite. In other 
words, all the measurements other than the reference pseudo-range, are represented 
as deltas referenced to a common reference value. Such an approach 
allows the reduction of message length. The first field in the structure SlotRec 
should be handled depending on whether the structure’s “slot number” is zero or 
not. 
4. 
Field num from the structure Header shows the total number of slot records (see 
the structure “SlotRec”). For example, if only C/A measurements are enabled in 
the message, the field num will be zero. 
[rV] Receiver’s Position and Velocity 

struct PosVelVector {42} {
u2 sample; // Sample number [] 
u2 delta; // [bitfield]:


// 15…5: Difference between the raw measurement time 
// (available from either [rM] or [rE] message) 
// and the position time tag [-1024…1023], [5 ms] 
// 4…0: reserved 

u4 word1; 
// 32 MSB of Position X-component; 

u4 word2; 
// [bitfield]:
// 31…24: 8 LSB of Position ECEF X-component [10-4 m]
// or Latitude [10-11 radians] 
// or Grid (Local) X-component [10-4 m];
// 23: 1 - indicates that Position is valid 
// 22…21: 0 – Position is given in ECEF system 
// 1 – Position is given in geodetic coordinates 
// (latitude, longitude, height above 
// ellipsoid) 
// 2 – Position is given in grid (or local) 
// coordinates 
// 3 – reserved 
// 20…16: Number of GPS SVs used in computation; 
// 15: 1 - indicates that Velocity is valid 

120 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Integrated Messages 

// 14…13: reserved 
// 12…8: Number of GLONASS SVs used in computation; 
// 7…4: Position computation mode 
// (see Table 3-3 on page 66); 
// 3…0: Velocity computation mode 
// (see Table 3-3 on page 66); 


u4 word3; 
// 32 MSB of Position Y-component; 

u4 word4; 
// 31…24: 8 LSB of Position ECEF Y-component [10-4 m]
// or Longitude [10-11 radians] 
// or Grid (Local) Y-component [10-4 m];
// 23…15: PDOP * 10 []; 
// 14…0: RMS velocity error [0.001 meters]; 

u4 word5; 
// 32 MSB of position Z-component; 

u4 word6; 
// [bitfield]:
// 31…24: 8 LSB of position ECEF Z-component 
// or Height above ellipsoid or geoid11 [10-4 m]; 
// 23…20: reserved; 
// 19…0: RMS Position error [0.001 m]; 

u4 word7; 
// [bitfield]:
// 31…4: velocity X-component [10-4 m/s]
// or East component (if types 1 and 2 are 
// selected in bits 22…21 of the ‘word2’ field); 
// 3…2: reserved; 
// 1…0: 2 MSB of GREIS datum number (see note below); 

u4 word8; 
// [bitfield]:
// 31…4: velocity Y-component [10-4 m/s]
// or North component (if types 1 and 2 are 
// selected in bits 22…21 of the ‘word2’ field); 
// 3…0: bits 7…4 of datum number; 

u4 word9; 
// [bitfield]:
// 31…4: velocity Z-component [10-4 m/s]
// or Height component (if types 1 and 2 are 
// selected in bits 22…21 of the ‘word2’ field); 
// 3…0: 4 LSB of GREIS datum number; 

u2 crc16; // 16-bit CRC;
}; 


Note: 
For GREIS datum numbers, please refer to “Reference Ellipsoids and Local Datums” available 
from http://www.javad.com. Currently GREIS datum numbers range between zero and 221. 

[rT] Receiver Clock Offsets 

struct ClockOffsets {var} {
u2 sample; // Sample number []
u2 reserved; // Reserved for future extensionsu1 recSize; // Size of data block, in bytes, that corresponds to

// the given satellite system (8 bytes currently);

ClkOffs Offs[N]; // Clock offsets (see below). 
// ‘N’ can be derived from the following expression:
// N = (len - 7) / recSize, where ‘len’ is message body// length taken from message header

u2 crc16; // 16-bit CRC 
}; 


11. Depending on the value of /par/raw/rtm/geoid parameter 
GREIS 
www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Interactive Messages 

struct ClkOffs {

u4 word1; // [bitfield]:
// 31: reserved; 
// 30: if set, improved timing mode is turned on; 
// 29…0: clock offset [10-4 meters], bit combination 
// 0x20000000 means the clock offset is 
// unavailable or exceeds ±536870911; 

u4 word2; 
// [bitfield]:
// 31…29: reserved; 
// 28…26: navigation system (0 - GPS, 1 - GLN); 
// 25…0: derivative of clock offset [10-4 m/s],
// bit combination 0x2000000 means that clock 
// offset is unavailable or exceeds ±33554431; 

}; 

3.4.16 Interactive Messages 
Commands sent to the receiver may generate reply messages from the receiver. These 
human-readable text messages are output immediately as a response to corresponding 
commands. Interactive applications are the target for this class of messages. 

[RE] Reply 

struct RE {var} {
a1 reply[]; // Reply
}; 


The contents of a reply message depends on what particular command has invoked this 
reply message (see Chapter 2 for more information about GREIS receiver commands 
and possible replies). 

[ER] Error 

struct ER {var} {
a1 error[]; // Error description
}; 


If receiver gets a command that, for some reason, can't be executed, or produce an error 
during execution, then an error message is generated. The contents of the error message 
specifies what is wrong with the issued command. 

122 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Miscellaneous Messages 

3.4.17 Miscellaneous Messages 
[IO] GPS Ionospheric Parameters 
struct IonoParams {39} {

u4 tot; // Time of week [s] 

u2 wn; // Week number (taken from the first subframe) 

// The coefficients of a cubic equation representing 

// the amplitude of the vertical delay

f4 alpha0; // [s]

f4 alpha1; // [s/semicircles]

f4 alpha2; // [s/semicircles2]

f4 alpha3; // [s/semicircles3]

// The coefficients of a cubic equation representing 

// the period of the model

f4 beta0; // [s] 

f4 beta1; // [s/semicircles] 

f4 beta2; // [s/semicircles2]

f4 beta3; // [s/semicircles3]

u1 cs; // Checksum 

}; 

This message contains ionospheric correction parameters from GPS subframe 4, page 

18. These parameters relate to an ionospheric model mainly used by single frequency 
GPS receivers. 
For more information about this ionosphere model, please see ICD-GPS-200C, Revision 
IRN-200C-004 April 12, 2000. 

[QI] QZSS Ionospheric Parameters 

struct QzssIonoParams {39} {

IonoParams par;

}; 

This message contains ionospheric correction parameters from QZSS sub-frame 4, page 

18. These parameters belong to the ionospheric model generally being used by single 
frequency GPS/QZSS receivers and are optimized for Japan area. 
[CI] BeiDou Ionospheric Parameters 
struct BeiDouIonoParams {39} {

IonoParams par;

}; 

This message contains ionospheric correction parameters from BeiDou sub-frame 1. 

These parameters relate to an ionospheric model mainly used by single frequency Bei-
Dou receivers. 

GREIS www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Miscellaneous Messages 

[II] IRNSS Ionospheric Parameters 
struct IrnssIonoParams {39} {
IonoParams par;
}; 


This message contains ionospheric correction parameters from IRNSS data. These 
parameters relate to an ionospheric model mainly used by single frequency IRNSS 
receivers. 

[==](EV) Event 

struct Event {var} {
u4 time; // Receiver time of event occurrence modulo day, [ms] 
u1 type; // Event type (see below), []
u1 data[]; // Event contents
u1 cs; // Checksum 


}; 

This message is generated (if enabled) every time some event occurs in the receiver. 
Currently the following event types are defined: 

0 – free-form event. Is generated by the “event” command (see “event” on page 48). 
1 – firmware warning. The “data” field describes the warning in human-readable 
form. 

[LT] Message Output Latency 

struct Latency {2} {
u1 lt; // output latency [ms]
u1 cs; // Checksum


}; 

This message contains the difference between the actual output time of the first of the 
messages sent to the output stream at the given epoch, and this epoch's time-tag. Note 
that latency for an output stream may depend on the amount of messages requested to a 
different stream. For example, the more messages are output to port A, the bigger the 
latency of port B; this is because the receiver begins generation of messages for port B 
only after it has finished generating messages for port A. 

[>>] Wrapper 

struct Wrapper {var} {
u1 id; // Source identifier
u1 data[size]; // Data from the source
a1 cs[2]; // Checksum formatted as hexadecimal 


}; 

124 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Miscellaneous Messages 

This message is intended to wrap up arbitrary data. The size of the wrapped data (in 
bytes) is equal to the message length from the header less 3 (size=L-3). 

This message is used for two different purposes: 

1. 
To wrap data from an input stream that has been set to the “wrapped echo 
mode” (see /par/[port]/ewrap and /par/[port]/echo parameters). In this case it 
is generated whenever some data come to the stream. The “id” field then contains 
input stream identifier: 
id Source Stream 
‘a’…’d’ serial ports A…D, /dev/ser/a…/dev/ser/d 
‘A’…’E’ TCP ports A…E, /dev/tcp/a…/dev/tcp/d 
‘U’ USB port A, /dev/usb/a 
‘H’ Bluetooth port A, /dev/blt/a 
‘N’ CAN port A, /dev/can/a 
‘P’ TCP client port, /dev/tcpcl/a 
‘V’ UDP port 

2. 
To wrap arbitrary message(s) during periodic messages output, as specified by 
the em command for corresponding messages. In this case the id field is set to be 
numerically equal to (-1 -count), where count is the field from the message 
scheduling parameters. See “Periodic Output” on page 20 and “em & out” on 
page 35 for details. 
Note: 
This message is not subject to enabling/disabling using the em and dm commands. It is generated 
and output using its own rules. 

[PM] Parameters 

struct Params {var} {
a1 params[]; // Parameters descriptiona1 delim[2] = “,@”; // Checksum delimitera1 cs[2]; // Checksum formatted as hexadecimal 

}; 

This message contains information on (most of) receiver parameters. When enabled, it 
will also be output every time one of the receiver parameters is changed. 

Due to large number of parameters only part of a whole receiver parameter tree is output 
at every epoch, and multiple [PM] messages are typically output per epoch. In addition, 
a few starting [PM] messages containing values for specific parameters are output at the 
first receiver epoch after enabling the message. 

The starting messages and messages generated at the time of updating of receiver 
parameters have the following format: 

GREIS 
www.javad.com 


RECEIVER MESSAGES 
Standard Predefined Messages 

Miscellaneous Messages 

NAME=VALUE 


where NAME denotes the parameter name, and VALUE denotes the parameter value. 

The other messages have a slightly different format, specifically: 

{[ITEM[,ITEM…]]} 

where ITEM denotes either the value of a parameter, or a comma-separated list of 
ITEMs surrounded by braces. 

[LH] Logging History 

struct LoggingHistory {var} {
u1 svsCount; // Number of SVs 
u1 targetStream; // Stream ID 
u2 issue; // Issue of the history 
u2 bitsCount; // Number of bits 
u4 lastBitTime; // Time since the last history shift [ms]
u1 uids[svsCount]; // SVs UIDs
u1 pad[padCount]; // Padding
u4 hist[elemsCount][svsCount]; // History bits


}; 

This message contains history of logging of satellites data into particular stream. For a 
description of how logging history works and parameters governing logging history, see 
“Logging History” on page 338. 

Fields description: 

svsCount – Number of SVs in this history. 
targetStream – The stream ID the history is gathered for (see description of the 


[>>] message for details). 
issue – The issue of the history. It is incremented every time the history is changed. 
bitsCount – Number of bits in this history. This history contains this number of bits 

for every SV specified in the uids field. 
lastBitTime – Time in milliseconds since the last history shift. 
uids[svsCount] – Array of SVs UIDs 
pad[padCount] – Padding (with zeroes) to align the next field on 4 bytes boundary, 

fillCount = (4 - (svsCount % 4)) % 4 
hist[elemsCount][svsCount] – History bits. For every SV, the bits are packed into 
array of u4 values. Most significant bit of the first element of the array represents 
most recent bit of the history. Least significant bit of the last element of the array 
represents the oldest bit of the history when there are enough history bits to fill the 
last u4 element. The number of u4 elements in the array is just enough to hold 
bitsCount bits: 

126 
www.javad.com GREIS 


RECEIVER MESSAGES 
Standard Predefined Messages 

Miscellaneous Messages 

elemsCount = (bitsCount + 31) / 32 
Exactly svsCount bit arrays are put into the message in the order specified by the 
uids field. 

[BI] Base Station Information 

struct BaseInfo {28} {
f8 x, y, z; // ECEF coordinates [m]
u2 id; // Reference station ID
u1 solType; // Solution type
u1 cs; // Checksum 


}; 

[SE] Security 

struct Security {6} {
u1 data[5]; // Opaque data
u1 cs; // Checksum 


}; 

This message is for JAVAD GNSS internal use. 

[SM] Security for [rM] 

struct Security {8} {
u1 data[6]; // Opaque data
u2 crc16; // 16-bit CRC 


}; 

This message is for JAVAD GNSS internal use. 

[TT] CA/L1 Overall Continuous Tracking Time 

struct TrackingTime {5} {
u4 tt; // tracking time [s]
u1 cs; // Checksum


}; 

This message contains time elapsed since the last loss-of-lock of all CA/L1 signals. 
Time count starts as soon as the first CA/L1 signal is locked on. Should a loss of lock of 
the last CA/L1 signal occur, the time counter is reset to zero. 

[OO] Oscillator Offset 

struct RcvOscOffs {5} {
f4 val; // Oscillator offset [s/s]
u1 cs; // Checksum 


}; 

